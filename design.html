{% extends 'base.html' %}

{% load static %}
{% load custom_wiki_tags %}

{% load django_bootstrap5 %}

{% block content %}
<title>Sandbox</title>
<link rel="stylesheet" href="{% static 'css/leaflet.css' %}"/>
<script src="{% static 'js/leaflet.js' %}"></script>

<!-- Leaflet Lasso -->
<script src="{% static 'js/leaflet-lasso.umd.min.js' %}"></script>

<!-- Leaflet Geoman -->
<link rel="stylesheet" href="{% static 'css/leaflet-geoman.css' %}"/> 
<script src="{% static 'js/leaflet-geoman.min.js' %}"></script>

<!-- Leaflet Print -->
<link rel="stylesheet" href="{% static 'css/Leaflet.BigImage.min.css' %}">
<script src="{% static 'js/Leaflet.BigImage.min.js' %}"></script>

<!-- Leaflet Ruler -->
<script src="{% static 'js/leaflet-ruler.js' %}"></script>
<link rel="stylesheet" href="{% static 'css/leaflet-ruler.css' %}"/>

<!-- Leaflet PouchDB Caching -->
<script src="{% static 'js/pouchdb.js' %}"/> 
<script src="{% static 'js/L.TileLayer.PouchDBCached.js' %}"></script>

<script src="{% static 'js/xlsx.full.min.js' %}"></script>

<script src="{% static 'js/md5.js.js' %}"></script>

<script src="{% static 'js/jquery-3.7.1.min.js' %}"></script>
<script src="https://cdn.jsdelivr.net/npm/leaflet-rotatedmarker@0.2.0/leaflet.rotatedMarker.min.js"></script>

<!-- DataTables Libraries -->
<link rel="stylesheet" type="text/css" href="{% static 'css/jquery.dataTables.css' %}">
<script type="text/javascript" src="{% static 'js/jquery.dataTables.min.js' %}"></script>
<link rel="stylesheet" type="text/css" href="{% static 'css/buttons.dataTables.min.css' %}">
<script type="text/javascript" src="{% static 'js/dataTables.buttons.min.js' %}"></script>
<script type="text/javascript" src="{% static 'js/buttons.colVis.min.js' %}"></script>
<link rel="stylesheet" type="text/css" href="{% static 'css/colReorder.dataTables.min.css' %}">
<script type="text/javascript" src="{% static 'js/dataTables.colReorder.min.js' %}"></script>
<script src="https://cdn.datatables.net/1.11.3/js/dataTables.bootstrap5.min.js"></script>
<script src="https://cdn.datatables.net/1.11.3/js/jquery.dataTables.min.js"></script>
<script type="text/javascript" src="{% static 'js/FileSaver.js' %}"></script>
<script src="{% static 'js/papaparse.min.js' %}"></script>
<script src="https://unpkg.com/esri-leaflet@3.0.2/dist/esri-leaflet.js"></script>

<script src="{% static 'leaflet/leaflet-GIBS-master/src/GIBSMetadata.js' %}"></script>
<script src="{% static 'leaflet/leaflet-GIBS-master/src/GIBSLayer.js' %}"></script>

<link rel="stylesheet" href="{% static 'css/choices.min.css' %}" />

<script src="{% static 'js/choices.min.js' %}"></script>

<script src="https://unpkg.com/leaflet.vectorgrid/dist/Leaflet.VectorGrid.bundled.js"></script>


<script src='//api.tiles.mapbox.com/mapbox.js/plugins/leaflet-omnivore/v0.3.1/leaflet-omnivore.min.js'></script>

<style>
    @media only screen and  (max-width: 1500px) {
        span.nav-text {
          display: none !important;
        }
      }
    :root {
        --selectedMarkerColor: #ff00ff;
        --selectedPolygonColor: #ff00ff;
    }
    .svg-icon-container {
        position: relative;
        display: inline-block;
        /* Ensure the container is large enough to visually contain the SVG and handles */
    }
    /* Dropdown button */
.dropdown-button {
    text-decoration: none;
    padding: 10px;
    background: white;
    color: black;
    border: none;
    font-size: 16px;
}


main.container {
    min-width: 100%;
    font-size: .82rem;
}
/* Dropdown content (hidden by default) */
.dropdown-content {
    display: none;
    position: absolute;
    background-color: #f9f9f9;
    min-width: 160px;
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    z-index: 1;
}

/* Links inside the dropdown */
.dropdown-content label {
    color: black;
    padding: 12px 16px;
    text-decoration: none;
    display: block;
}
.leaflet-control-layers-expanded {
    padding: 0px;

}

.carousel-control-prev-icon {
    background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 8 8'%3E%3Cpath d='M5.25 0l-4 4 4 4 1.5-1.5-2.5-2.5 2.5-2.5-1.5-1.5z'/%3E%3C/svg%3E") !important;
   }
   
.carousel-control-next-icon {
    background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 8 8'%3E%3Cpath d='M2.75 0l-1.5 1.5 2.5 2.5-2.5 2.5 1.5 1.5 4-4-4-4z'/%3E%3C/svg%3E") !important;
}
.carousel-indicators button {
    height: 6px !important;
}
/* Change color of dropdown links on hover */
.dropdown-content label:hover {
    background-color: #f1f1f1;
}
    .interaction-handle {
        position: absolute;
        width: 24px; /* Adjust size as needed */
        height: 24px; /* Adjust size as needed */
        border-radius: 50%; /* Circular shape */
        background-color: #FFF; /* Light background for contrast */
        color: #333; /* Icon/text color */
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 18px; /* Adjust icon size as needed */
        box-shadow: 0 2px 4px rgba(0,0,0,0.2); /* Soft shadow for depth */
        cursor: pointer; /* Indicate interactivity */
        border: 1px solid #AAA; /* Subtle border for definition */
    }
    
    /* Positioning the handles in a loose circle around the SVG content */
    .rotate-handle {
        top: -12px; /* Adjust as needed */
        left: 50%;
        transform: translateX(-50%);
    }
    
    .resize-width {
        right: -12px;
        top: 50%;
        transform: translateY(-50%);
    }
    
    .resize-height {
        left: -12px;
        top: 50%;
        transform: translateY(-50%);
    }
    
    .resize-scale {
        bottom: -12px;
        left: 50%;
        transform: translateX(-50%);
    }
    
    .toggle-paths-container > a {
        border: none;
      }
      .toggle-paths-container {
        padding: 0px !important;
    }
    .toggle-lrf-lines {
        background-image: url("{% static 'img/lrf-path-explode.png' %}");
        background-repeat: no-repeat;
        background-position: center;
        background-size: contain;
        width: 30px; /* Adjust as needed */
        height: 30px; /* Adjust as needed */
        background-size: 28px;
    }
    /* Change color of dropdown links on hover */
.dropdown-content label:hover {
    background-color: #f1f1f1;
}
.pm-textarea {
    background-color: #ffffffb5 !important;
    padding-left: 3px !important;
}
/* nav-bar */
li.nav-item.dropdown.me-1 {
    font-size: .75rem;
}
i.bi.icons {
    font-size: 1rem;
}
.toggle-range-ring-layers {
    /* icon Created by Eliricon from the Noun Project */
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' data-name='Layer 1' viewBox='0 0 100 125' x='0px' y='0px'%3E%3Ccircle cx='18.45658' cy='84.10036' r='6.081' transform='translate(-54.06212 37.6832) rotate(-45)'/%3E%3Ccircle cx='32.93522' cy='84.10036' r='6.081' transform='translate(-49.82143 47.92114) rotate(-45)'/%3E%3Ccircle cx='47.41386' cy='84.10036' r='6.081' transform='translate(-45.58074 58.15908) rotate(-45)'/%3E%3Ccircle cx='76.37113' cy='84.10036' r='6.081' transform='translate(-37.09935 78.63497) rotate(-45)'/%3E%3Cpath d='M45.63729,48.43692l2.89844-2.89844-.93671-7.2536,19.19-19.19-.002-.002c.02045-.02014.04187-.0379.06219-.05822,2.76062-2.76062,3.54255-6.45453,1.74646-8.25055-1.796-1.79608-5.48992-1.01416-8.25054,1.74646-.02033.02032-.03815.04175-.05829.06219l-.002-.00195L41.09493,31.78073,33.84127,30.844l-4.2702,4.27021,4.09521,4.09515L16.52383,56.35184l-7.25367-.93671L5,59.68527l4.09522,4.09516-.00006.00006,1.95831,1.95831L5,77.705v6.39532H9.76943a8.68551,8.68551,0,0,1,15.92645-4.79822,8.68254,8.68254,0,0,1,14.4787,0A8.68551,8.68551,0,0,1,56.101,84.10031H67.68392a8.68723,8.68723,0,0,1,17.37445,0h4.59906L95,73.53946V69.80881H84.32015V66.175H95V61.44553H58.64584Zm-21.199,13.00861L40.128,45.75583l15.6897,15.6897Z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: center;
    background-size: 25px 25px;
    width: 16px; /* Adjust as needed */
    height: 16px; /* Adjust as needed */
    border: none !important;
}
.toggle-log-ring-layers {
    /* Created by Funtasticon
    from Noun Project */
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 100 100 '%3E%3Cpath d='m95.789 52.16v13.59c-0.003906 2.0977-1.6914 3.7969-3.7891 3.8203h-0.60156c0-5.7812-4.6875-10.469-10.469-10.469s-10.469 4.6875-10.469 10.469h-3.3828v-35.199h6.2695l0.003906 12.629c0.003907 2.8438 2.3047 5.1445 5.1484 5.1484zm-17.289-2.6719h16.641l-6.3203-13c-0.62891-1.3203-1.9688-2.1562-3.4297-2.1367h-9.3906v12.648c0.003906 1.3672 1.1133 2.4727 2.4805 2.4805zm-17.91-26.848h-52.59c-2.1055 0-3.8164 1.7031-3.8203 3.8086v39.301c0.003906 2.1094 1.7109 3.8164 3.8203 3.8203h1.7891c0-5.7812 4.6875-10.469 10.473-10.469 5.7812 0 10.469 4.6875 10.469 10.469h33.668v-43.121c-0.003907-2.1016-1.707-3.8047-3.8086-3.8086zm28.141 46.93c0 3.1562-1.9023 6-4.8164 7.207-2.9141 1.207-6.2695 0.53906-8.5-1.6914-2.2305-2.2305-2.8984-5.5859-1.6914-8.5 1.207-2.9141 4.0508-4.8164 7.207-4.8164 4.3086 0 7.8008 3.4922 7.8008 7.8008zm-5.4414 0c0-0.95312-0.57422-1.8164-1.457-2.1797-0.87891-0.36719-1.8945-0.16406-2.5703 0.51172-0.67578 0.67578-0.87891 1.6875-0.51172 2.5703 0.36328 0.88281 1.2266 1.457 2.1797 1.457 1.3047 0 2.3594-1.0547 2.3594-2.3594zm-55.23 0c0 3.1562-1.8984 6-4.8125 7.207-2.9141 1.207-6.2695 0.53906-8.5-1.6914-2.2305-2.2305-2.8984-5.5859-1.6914-8.5 1.207-2.9141 4.0508-4.8164 7.207-4.8164 4.3047 0 7.7969 3.4922 7.7969 7.8008zm-5.4414 0h0.003906c0-0.95312-0.57422-1.8164-1.457-2.1797-0.88281-0.36719-1.8984-0.16406-2.5742 0.51172-0.67188 0.67578-0.875 1.6875-0.51172 2.5703 0.36719 0.88281 1.2266 1.457 2.1836 1.457 0.625 0.003906 1.2266-0.24609 1.6719-0.6875 0.44141-0.44531 0.6875-1.0469 0.6875-1.6719z' fill-rule=''/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: center;
    background-size: 25px 25px;
    width: 16px; /* Adjust as needed */
    height: 16px; /* Adjust as needed */
    border: none !important;
}
.toggle-paths-container {
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='%23000000' d='M92.6 21c-32 0-64.04 24-64.04 72L92.6 221l64-128c0-48-32-72-64-72zm282.3 39c-6.9.29-13.6 1.6-19.2 2.8l3.8 17.6c5.6-1.25 11.4-2.04 16.3-2.4zM92.6 61c17.7 0 32 14.33 32 32 0 17.7-14.3 32-32 32-17.67 0-32-14.3-32-32 0-17.67 14.33-32 32-32zm302.2.2l-3 17.7c4.9 1.03 9.8 2.32 14.1 4.9l8.7-15.8c-6.1-3.25-12.9-6.17-19.8-6.8zm-57.5 6.7c-6.1 2.38-12.2 4.51-17.4 6.6L327 91c5.5-2.34 11.3-4.38 16.2-6.1zM431 81.3L417.3 93c3.6 4.12 6.4 9.2 8.6 13.3l16.1-8.1c-3.4-6.55-6.4-11.51-11-16.9zm-127.8.9c-6.1 3.11-11.1 5.88-16.5 8.6l8.8 15.8c5.2-3 10.9-5.9 15.5-8.2zm-32.3 17.9c-5.3 3.1-10.5 6.2-15.6 9.6l9.8 15c4.9-3.2 10-6.2 15-9.2zM448.2 118c-5.9 1-11.9 1.7-17.8 2.4.4 5 .1 10.4-.9 14.6l17.5 4.1c1-7.2 1.9-14.6 1.2-21.1zm-208.1 1.7c-5 3.4-9.9 6.9-14.9 10.3l10.4 14.7c4.8-3.5 9.7-6.8 14.6-10.2zm-29.6 21.1c-5 3.6-10.2 7.6-14.5 10.9l10.9 14.3c5.5-4 9.3-7 14.3-10.7zm213 8c-3 4.6-6.5 9.2-10 12.7l13.1 12.5c4.3-5.1 8.9-10.3 12.1-15.5zm-241.8 14.1c-4.9 3.8-9.8 7.7-14.1 11.3l11.4 13.9c4.7-3.9 9.5-7.9 13.9-11.1zM401.1 173c-4.6 3.7-9.4 7.3-13.8 10.3l10.3 14.8c5.3-3.6 10.5-7.5 15-11.1zm-247.4 12.9c-4.7 3.8-9.2 7.8-13.8 11.7l11.7 13.7c4.5-3.9 9-7.8 13.6-11.6zm218.9 7c-5.1 3-10.4 6.1-15.2 8.7l8.6 15.9c5.4-3.3 11.5-6.2 16-9.2zm-246.4 16.6c-4.5 4-8.9 8-13.4 12.1l12.1 13.4c4.4-4 8.9-8 13.3-12zm215.5.4c-5.3 2.6-10.6 5.3-15.9 7.9l7.7 16.2c6.2-3 10.8-5.5 16.4-8.1zm-32 15.4c-5.5 2.5-10.8 4.9-16.4 7.2l7.3 16.5c5.5-2.4 11-4.9 16.5-7.4zM99.6 234c-5.1 4.5-8.65 8-13.3 12.5l12.7 13c4.7-4.5 8.5-8.4 12.9-12.2zm177.3 5.8c-5.5 2.3-11 4.7-16.5 7l7 16.7c5.6-2.3 11.1-4.7 16.6-7.1zm-33.1 14c-5.5 2.4-11 4.8-16.6 7l7 16.7c5.5-2.3 11.1-4.7 16.6-7zm184.8 7.2c-32 0-64 24-64 72l64 128 64-128c0-48-32-72-64-72zm-218 6.8c-5.7 2.6-11.7 5-16.6 7.1l7.1 16.6c5.9-2.5 11.5-4.9 16.5-7.1zM177.4 282c-5.4 2.5-11.7 5.3-16.5 7.5l7.4 16.4c5.9-2.6 11.1-5.2 16.3-7.4zm-33 15c-5.6 2.7-11.4 5.5-16.4 8l8.1 16.1c5.4-2.8 11-5.4 15.9-7.8zm284.2 4c17.7 0 32 14.3 32 32s-14.3 32-32 32-32-14.3-32-32 14.3-32 32-32zm-316.8 12.3c-5.3 2.9-10.6 5.9-16 9l9 15.6c5.1-3 10.3-5.8 15.5-8.6zM80.1 332c-5.61 3.2-11.03 7.5-15.7 10.6L75.3 357c4.97-3.6 10.32-7.3 14.6-9.9zm-29.9 22.6c-4.8 4.4-9.53 9.5-13.2 13.8l13.7 11.7c3.85-4.7 7.2-8.2 11.7-12.2zm217.8 1.3l1.6 17.9c5.2-.9 10.4-.3 15.6.5l3.1-17.7c-6.6-1-13.6-1.7-20.3-.7zm-37.2 10l6.8 16.7c5.2-2.3 10.6-4.1 16.1-5.8-1.9-5.7-3.3-11.5-4.8-17.3-6.3 1.8-12.6 4.2-18.1 6.4zm77.5-.9l-10.2 14.8c4.2 3.1 8.3 6.4 11.6 10.5l13.6-11.8c-5.1-5.2-9-10.1-15-13.5zm-94.5 9c-5.5 2.8-10.8 6-16.1 9.1l9.1 15.5c5.2-2.8 10.3-6.1 15.4-8.8zM26.01 385c-3.02 6.5-5.47 13.5-6.61 19.7l17.7 3.1c1.08-5.7 2.63-9.8 4.9-14.7-5.49-2.4-10.73-5.3-15.99-8.1zm156.09 7.8c-5.1 3.3-10.1 6.6-15.1 10l10 15c5-3.3 9.9-6.7 14.9-10zm152.7 1.2l-15.1 9.8c3.2 4.8 6.3 9.8 9.2 14.9l15.6-9c-3.5-5.6-6-10.6-9.7-15.7zm-182.7 19c-5 3.3-10 6.5-14.9 10l10 15c4.8-3.5 9.9-6.8 15-10.2zm-114.8 9.5c-5.79 1.2-11.63 2.2-17.45 3.3 1.05 7 3.86 13.8 6.4 19.2l16.25-7.8c-2.17-5-4.23-10.2-5.2-14.7zm316.1 2.8l-15.6 9c3.1 5.4 6.7 11.2 9.6 15.8l15.1-9.7c-3.4-5.3-6.3-10.3-9.1-15.1zm-231 7.5c-5 3.1-9.9 6.1-15.1 9l8.9 15.7c5.3-3.1 10.6-6.2 15.7-9.5zm-71.3 16.3l-12.3 13.2c5.56 5.3 12.42 8.8 19.9 10.4l4-17.5c-4.44-.9-8.59-3.1-11.6-6.1zm41 .3c-5.01 2.3-10.21 4.1-15.6 5.2l4.1 17.6c6.42-1.3 12.46-3.7 18.5-6.2zm280.3 4.8l-13.9 11.3c4.3 5.3 9.6 10.4 14.2 14l11.1-14.2c-4.4-3.4-8.2-7.5-11.4-11.1zm24.1 17.5l-4.5 17.5c7.9 1.6 13.8 2.1 21.2 1.3l-2.2-17.9c-4.9.8-9.7.3-14.5-.9z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: center;
    background-size: 25px 25px;
    width: 32px; /* Adjust as needed */
    height: 32px; /* Adjust as needed */
    border: none;
}
.toggle-paths-container a:hover, toggle-paths-container a:focus {
    background-color: #f4f4f4;
}
.leaflet-control-custom {
    border: none;
}
.leaflet-pm-icon-polyline-lrf {
    background-image: url("{% static 'img/lrf-icon.png' %}");
}
.layer-mgmt-dropdown-button {
    background-image: url("{% static 'img/layer_mgmt.svg' %}") !important;
    background-repeat: no-repeat;
    background-position: center;
    background-size: contain;
    width: 30px; /* Adjust as needed */
    height: 30px; /* Adjust as needed */
    background-color: white;
    border: none;
}
.layer-display-dropdown-button {
    background-image: url("{% static 'img/layers.svg' %}") !important;
    background-repeat: no-repeat;
    background-position: center;
    background-size: contain;
    width: 30px; /* Adjust as needed */
    height: 30px; /* Adjust as needed */
    background-color: white;
    border: none;
}

/* Style for the overlay */
#zoomOverlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 10px 20px;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border-radius: 5px;
    font-size: 16px;
    display: none; /* Hidden by default */
    pointer-events: none; /* Allows clicks through the overlay */
    z-index: 1000; /* Sit on top */
}

.add-svg-control .svg-preview {
cursor: pointer;
border: 1px solid #ddd;
margin: 5px;
padding: 5px;
display: inline-block;
}

.text-extra-small {
font-size: 0.9rem; /* Adjust the size as needed */
}
.add-svg-control .svg-preview:hover {
background-color: #f0f0f0;
}

main.container {
min-width: 100%;
}
#MapDataTable {
    font-size: 0.7rem !important;
}
.selected-marker-color {
filter: drop-shadow(0 7px 6px var(--selectedPolygonColor));
}

.selected-polygon-color {
filter: drop-shadow(0 7px 6px var(--selectedPolygonColor));
}


.selected-marker-red {
filter: drop-shadow(0 0 0.75rem red);
}
.selected-marker-black {
filter: drop-shadow(0 0 0.75rem black);
}
.team-banner-purple {
background-color: #720FF6;
color: #fff;
border-radius: 0 0 10px 10px;
text-align: center;
}
.team-banner-red {
background-color: #C91E37;
color: #fff;
border-radius: 0 0 10px 10px;
text-align: center;
}
.team-banner-blue {
background-color: blue;
color: #fff;
border-radius: 0 0 10px 10px;
text-align: center;
}
.dt-icon {
    border: none;
    background: none;
}
.team-banner.white-cell {
background-color: #ffffff;
color: #000
}

.topo-data {
position: absolute;
top: 10px;
right: 10px;
background: white;
padding: 10px;
border: 1px solid #ccc;
white-space: pre-wrap;
z-index: 1000;
}
.leaflet-control-topo-hover {
background-color: #fff;
border: 2px solid #ccc;
border-radius: 4px;
box-shadow: 0 1px 4px rgba(0,0,0,0.65);
margin-bottom: 10px;
}
.leaflet-control-topo-hover button {
background: none;
border: none;
color: #0078A8;
cursor: pointer;
font-size: 16px;
padding: 8px 12px;
}
.leaflet-control-topo-hover button:hover {
background-color: #f4f4f4;
}
.modal {
display: none; /* Hidden by default */
position: fixed; /* Stay in place */
z-index: 9999; /* Sit on top */
left: 0;
top: 0;
width: 100%; /* Full width */
height: 100%; /* Full height */
overflow: auto; /* Enable scroll if needed */
background-color: rgb(0,0,0); /* Fallback color */
background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
}

.modal-content {
background-color: #fefefe;
margin: 15% auto; /* 15% from the top and centered */
padding: 20px;
border: 1px solid #888;
width: 80%; /* Could be more or less, depending on screen size */
}

.close-button {
color: #aaa;
float: right;
font-size: 28px;
font-weight: bold;
}

.close-button:hover,
.close-button:focus {
color: black;
text-decoration: none;
cursor: pointer;
}
.disabled {
pointer-events: none;
cursor: default;
}
.table-menu-btn {
    height: 2.0rem;
}
.leaflet-pm-toolbar {
    display: flex;
    flex-wrap: wrap;
    width: 65px; /* Adjust the width based on your preference */
    box-shadow: grey 1px 1px 15px !important;
}

.leaflet-pm-toolbar .button-container {
    width: 50%; /* Each button takes up 50% width, creating two columns */
    box-sizing: border-box;
}
.leaflet-custom-button {
    border-top: 1px solid #cccccc;
}

.button-container .leaflet-pm-actions-container .leaflet-pm-action {
    position: relative;
    left: 64%;
}

</style>
<div id="zoomOverlay">Ctrl-Mouse Wheel to zoom in and out of the map</div>
<div class="">


<nav class="navbar navbar-expand-lg navbar-light bg-light">
    <div class="container-fluid">
        <!-- Brand/logo -->
        <!-- Toggler/collapsible Button -->
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <!-- Navbar links -->
        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="align-items-sm-baseline navbar-nav">
                <!-- Options Modal Trigger -->
                <li class="nav-item me-1" title="Options Menu" data-bs-toggle="tooltip" data-bs-placement="top">
                    <div type="button" class="nav-link" data-bs-toggle="modal" data-bs-target="#optionsModal">
                        <i class="bi icons bi-list"></i> <span class="nav-text">Options</span>
                    </div>
                </li>
                <li class="nav-item dropdown me-1" title="Reset Menu" data-bs-toggle="tooltip" data-bs-placement="top">
                    <!-- Dropdown Toggle -->
                    <a class="nav-link dropdown-toggle" href="#" id="markerDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                        <i class="bi icons bi-arrow-counterclockwise"></i> <span class="nav-text">Reset</span>
                    </a>
                    <!-- Dropdown Menu -->
                    <ul class="dropdown-menu" aria-labelledby="markerDropdown">
                        <li><a class="dropdown-item" href="#" onclick="restoreMarkerMoves()">Marker Moves</a></li>
                        <li><a class="dropdown-item" href="#" onclick="resetAllMarkerRotationAngles()">Marker Angles</a></li>
                    </ul>
                </li>

                <li class="nav-item me-1" title="Erase Markers" data-bs-toggle="tooltip" data-bs-placement="top">
                    <!-- Erase Markings -->
                    <div type="button" class="nav-link" onclick="clearAllPlanningMarkers()" title="Erase all markers">
                        <i class="bi icons bi-eraser"></i> <span class="nav-text">Clear Marks</span>
                    </div>
                </li>

                <li class="nav-item dropdown me-1" title="Selection Menu" data-bs-toggle="tooltip" data-bs-placement="top">
                    <!-- Dropdown Toggle Button -->
                    <a class="nav-link dropdown-toggle" href="#" id="selectionDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false" title="Selection">
                        <i class="bi icons bi-braces"></i> <span class="nav-text">Selection</span>
                    </a>
                    <!-- Dropdown Menu -->
                    <ul class="dropdown-menu" aria-labelledby="selectionDropdown">
                        <li><a class="dropdown-item" href="#" onclick="selectAllVisibleMarkers()" id="selectAllButton">Select All</a></li>
                        <li><a class="dropdown-item" href="#" onclick="deselectMarkers()" id="deselectButton">Deselect All</a></li>
                        <li><a class="dropdown-item" href="#" onclick="invertSelection()" id="invertSelectionButton">Invert Selection</a></li>
                    </ul>
                </li>

                <li class="nav-item me-1" title="Import OOB" data-bs-toggle="tooltip" data-bs-placement="top">
                    <!-- Import Button -->
                    <div type="button" class="nav-link" onclick="importData()" id="import" title="">
                        <i class="bi icons bi-upload"></i> <span class="nav-text">Import</span>
                    </div>
                </li>

                <li class="nav-item dropdown me-1" title="Load Menu" data-bs-toggle="tooltip" data-bs-placement="top">
                    <!-- Dropdown Button -->
                    <a class="nav-link dropdown-toggle" href="#" id="loadSavedFileDropdown" role="button" aria-haspopup="true" data-bs-toggle="dropdown" aria-expanded="false" title="Load a previously saved file">
                        <i class="bi icons bi-folder-symlink"></i> <span class="nav-text">Load</span>
                    </a>
                    <!-- Dropdown Menu -->
                    <ul class="dropdown-menu" aria-labelledby="loadSavedFileDropdown">
                        <li><a class="dropdown-item" href="#" data-bs-toggle="modal" data-bs-target="#uuidModal">From UUID</a></li>
                        <li><a class="dropdown-item" href="#" onclick="loadSavedFile()">From File</a></li>
                    </ul>
                </li>

                <li class="nav-item me-1" title="Save OOB" data-bs-toggle="tooltip" data-bs-placement="top">
                    <!-- Save Button -->
                    <div type="button" onclick="saveMapDataToFile_Helper()" class="nav-link" id="export" title="">
                        <i class="bi icons bi-floppy"></i> <span class="nav-text">Save</span>
                    </div>
                </li>

                <li class="nav-item me-1" title="Filter Visibility" data-bs-toggle="tooltip" data-bs-placement="top">
                    <div type="button" class="nav-link" data-bs-toggle="modal" data-bs-target="#filtersModal" onclick="populateFilterModal()">
                        <i class="bi icons bi-funnel"></i> <span class="nav-text">Visibility</span>
                    </div>
                </li>

                <li class="nav-item me-1" title="Download Army Graphics" data-bs-toggle="tooltip" data-bs-placement="top">
                    <!-- Download Army Graphics Button -->
                    <div type="button" class="nav-link" id="army-graphics" onclick="downloadArmyGix()" title="Download Army Graphics">
                        <i class="bi icons bi-star"></i> <span class="nav-text">Army Tact. Gix</span>
                    </div>
                </li>
                <li class="nav-item me-1" title="View Help" data-bs-toggle="tooltip" data-bs-placement="top">
                    <!-- Help Button -->
                    <div type="button" data-bs-toggle="modal" data-bs-target="#helpModal" class="nav-link" id="help" title="">
                        <i class="bi icons bi-question-circle"></i> <span class="nav-text">Help</span>
                    </div>
                </li>
                <li class="nav-item me-1" title="Hotkeys" data-bs-toggle="tooltip" data-bs-placement="top">
                    <!-- Hotkeys -->
                    <div type="button" data-bs-toggle="modal" data-bs-target="#hotkeysModal" class="nav-link" title="">
                        <i class="bi icons bi-keyboard"></i> <span class="nav-text">Hotkeys</span>
                    </div>
                </li>
                <li class="nav-item me-1">
                    <div class="text-truncate d-flex" role="search">
                        <input class="form-control me-2" id="search-input" type="search" placeholder="Search" aria-label="Search">
                        <button class="btn btn-outline-success" type="submit">
                            <i class="bi icons bi-crosshair2"></i> <span class="nav-text">Search</span>
                        </button>
                    </div>
                </li>

                <li class="nav-item ms-auto" title="New Features" data-bs-toggle="tooltip" data-bs-placement="top">
                    <div type="button" class="nav-link btn-sm btn btn-info" data-bs-toggle="modal" data-bs-target="#newFeaturesModal">
                        <i class="bi icons bi-app-indicator"></i> <span class="nav-text">New Features</span>
                    </div>
                </li>

                
            </ul>
        </div>
    </div>
</nav>
    
    <div class="map-container m-1">
        
        <div id="map" style="max-height: 90%; height: 80vh; min-width: 100%"></div>
    </div>  

</div>
<button class="btn btn-secondary table-menu-btn btn-sm d-flex" type="button" data-bs-toggle="collapse" data-bs-target="#collapseDatatable" aria-expanded="true" aria-controls="collapsemenu">
    
    <i class="bi bi-list me-2"></i><p>Expand Unit Table</p>
</button>
<div class="datatable-container collapse" id="collapseDatatable">
    
    <div class="adjudication-table-container w-100">
        <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <div class="container-fluid">
            <ul class="navbar-nav">

                <li class="nav-item me-1">
                <div type="button" class="nav-link" onclick="deselectMarkers()" id="deselectButton" title="Deselect all selected markers"><i class="bi icons bi-braces"></i>Deselect</div>
                </li>
                <li class="nav-item me-1">
                    <div type="button" onclick="refreshUniqueIDs()" class="nav-link" id="refresh-unique-id" title="Assign new unique ids to all unit markers"><i class="bi icons bi-arrow-repeat"></i>Refresh Unique IDs</div>
                </li>
                <!-- Export Button -->
                <li class="datatables-filters nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" id="navbarDropdownExportLink" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                    Export
                </a>
                <ul class="dropdown-menu align-items-baseline" aria-labelledby="navbarDropdownExport">
                    <li class="nav-item me-1">
                        <div type="button" class="nav-link" id="exportBtn" title="Export Markers"><i class="bi icons bi-cart3"></i>Export All</div>
                    </li>
                    <li class="nav-item me-1">
                        <div type="button" class="nav-link" id="exportBtn-view" title="Export Markers"><i class="bi icons bi-cart3"></i>Export View</div>
                    </li>
                    <!-- Refresh unique ID -->
                    
                </ul>
                </li>
            </ul>
            </div>
        </nav>
    </div>

    <table id="MapDataTable" class="display table table-striped" style="width:100%"></table>
</div>
<!-- New Features Modal -->
<div class="modal fade" id="newFeaturesModal" tabindex="-1" aria-labelledby="newFeaturesModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="newFeaturesModalLabel">What's New (Re-Access via "New Features")</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <!-- Carousel starts here -->
                <div id="carouselNewFeatures" class="carousel slide" data-bs-ride="carousel">
                    <div class="carousel-indicators">
                        <button type="button" data-bs-target="#carouselNewFeatures" data-bs-slide-to="0" class="active" aria-current="true" aria-label="Save and Load with a UUID"></button>
                        <button type="button" data-bs-target="#carouselNewFeatures" data-bs-slide-to="1" aria-label="Create a Layer"></button>
                        <button type="button" data-bs-target="#carouselNewFeatures" data-bs-slide-to="2" aria-label="Add/Remove From a Layer"></button>
                        <button type="button" data-bs-target="#carouselNewFeatures" data-bs-slide-to="3" aria-label="Delete a Layer"></button>
                        <button type="button" data-bs-target="#carouselNewFeatures" data-bs-slide-to="4" aria-label="View the Hotkeys"></button>
                    </div>
                    <div class="carousel-inner">
                        <div class="carousel-item active">
                            <h5>Now Save and Load with a Unique ID</h5>
                            <img src="{% wiki_media_url '/wiki/images/23/42026aaec66740d1917d882627ab6c6b/uuid-saves.png' %}" class="d-block w-100" alt="Save and Load with a UUID">
                        </div>
                        <div class="carousel-item">
                            <h5>Create a Custom Layer</h5>
                            <img src="{% wiki_media_url '/wiki/images/23/7eec5fb3b28b4649b28a039a41719f89/layer-create.png' %}" class="d-block w-100" alt="Create a Layer">
                        </div>
                        <div class="carousel-item">
                            <h5>Add or Remove Items from a Layer</h5>
                            <img src="{% wiki_media_url '/wiki/images/23/17b75260fbf04170bd8aac7a56da5d68/layer-add-remove.png' %}" class="d-block w-100" alt="Add/Remove From a Layer">
                        </div>
                        <div class="carousel-item">
                            <h5>Delete a Layer</h5>
                            <img src="{% wiki_media_url '/wiki/images/23/6d72aa7371c042b2956948e022541ab9/layer-trash.png' %}" class="d-block w-100" alt="Delete a Layer">
                        </div>
                        <div class="carousel-item">
                            <h5>View the Hotkeys</h5>
                            <img src="{% wiki_media_url '/wiki/images/23/444c1b3b2b344122a11467b96a392c12/view-hotkeys.png' %}" class="d-block w-100" alt="View Hotkeys">
                        </div>
                    </div>
                    <button class="carousel-control-prev" type="button" data-bs-target="#carouselNewFeatures" data-bs-slide="prev">
                        <span class="carousel-control-prev-icon" aria-hidden="true"></span>
                        <span class="visually-hidden">Previous</span>
                    </button>
                    <button class="carousel-control-next" type="button" data-bs-target="#carouselNewFeatures" data-bs-slide="next">
                        <span class="carousel-control-next-icon" aria-hidden="true"></span>
                        <span class="visually-hidden">Next</span>
                    </button>
                </div>
                <!-- Carousel ends here -->
            </div>
        </div>
    </div>
</div>



<!-- UUID Modal -->
<div class="modal fade" id="uuidModal" tabindex="-1" aria-labelledby="uuidModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="uuidModalLabel">Load from UUID</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label for="uuidInput" class="form-label">Enter UUID</label>
                    <input type="text" class="form-control" id="uuidInput" placeholder="Enter your UUID here">
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <button type="button" id="loadSavedFile" class="btn btn-primary">Load</button>
            </div>
        </div>
    </div>
</div>



<!-- Options Modal -->
<div class="modal fade" id="optionsModal" tabindex="-1" aria-labelledby="optionsModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="optionsModalLabel">Configure Behavior</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <!-- Popup Behavior Section -->
                <div class="popup-behavior">
                    <h6>Popup Behavior</h6>
                    <button type="button" class="btn btn-success active" id="dblClickBtn">Dbl Click</button>
                    <button type="button" class="btn btn-secondary" id="hoverBtn">Hover</button>
                </div>
                <!-- Mouse Wheel Zoom Section -->
                <div class="mouse-wheel">
                    <h6>Mouse Wheel Zoom</h6>
                    <button type="button" class="btn btn-success active" id="mouseWheelEnable">Enable</button>
                    <button type="button" class="btn btn-secondary" id="mouseWheelDisable">Disable</button>
                </div>
                <!-- Map Drag Section -->
                <div class="map-drag">
                    <h6>Map Drag</h6>
                    <button type="button" class="btn btn-success active" id="mapDragEnable">Enable</button>
                    <button type="button" class="btn btn-secondary" id="mapDragDisable">Disable</button>
                </div>
                <!-- Marker Size Section -->
                <div class="col">
                    <div class="map-option marker-size mt-4 form-control">
                        <h6>Marker Size</h6>
                        <span id="rangeValue">1</span>
                        <input type="range" class="form-range-marker-size" min="1" max="30" value="1" id="markerSize">
                    </div>
                </div>
                <div class="col">
                    <div class="map-option selection-color mt-4 form-control">
                        <h6>Marker Selection Color</h6>
                        <input type="color" id="colorPicker" class="selected-marker-color" name="favcolor" value="#FF00FF">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Help Modal -->
<div class="modal fade" id="helpModal" tabindex="-1" aria-labelledby="helpModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="helpModalLabel">Map Features Help</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <h6>Interacting with the Map</h6>
                <ul>
                    <li><strong>Import Feature:</strong> Use the "Import" button to load geographic data into the map.</li>
                    <li><strong>Dragging Icons:</strong> Click and drag any marker to reposition it on the map.</li>
                    <li><strong>Selecting Icons:</strong> Click a marker to select it. Use Ctrl + Click to select multiple markers or use the lasso tool for bulk selection.</li>
                    <li><strong>Bulk Move:</strong> After selecting multiple markers, drag any selected marker to move all selected markers simultaneously.</li>
                    <li><strong>Drawing Features:</strong> Utilize the drawing and editing controls on the top left to add or modify geometric shapes on the map.</li>
                    <li><strong>Popup Details:</strong> Double-click on any marker to view detailed information in a popup.</li>
                    <li><strong>Search Feature:</strong> Use the search bar to find markers. Press Enter to cycle through search results.</li>
                    <li><strong>Deselecting Icons:</strong> To deselect all currently selected markers, click the "Deselect" button.</li>
                    <li><strong>Resetting Markers:</strong> To reset all markers to their original positions, use the "Reset" button.</li>
                    <li><strong>Color Picker:</strong> To change the color of a shape on the map, select a color from the color picker, then click on the shape to apply the color.</li>
                    <li><strong>Changing the Base Tiles:</strong> Use the tile layer switcher on the top right to change the map's background.</li>
                    <li><strong>Team Affiliation Colors:</strong> Ensure the team column contains either blue or red values to display affiliations.</li>
                    <li><strong>Layer Management:</strong> Use the layer management panel to toggle the visibility of different map layers, reorder layers, and adjust their opacity.</li>
                    <li><strong>Adding to Layers:</strong> To add a new layer, use the "Add Layer" button and specify the layer details.</li>
                    <li><strong>Removing from Layers:</strong> To remove items from a layer, select the items and use the "Remove from Layer" option.</li>
                    <li><strong>Removing Layers:</strong> To remove an entire layer, select the layer and use the "Remove Layer" button.</li>
                </ul>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Hotkeys Modal -->
<div class="modal fade" id="hotkeysModal" tabindex="-1" aria-labelledby="hotkeysLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="hotkeysLabel">Hotkeys</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <h6>Hotkeys</h6>
                <ul>
                    <li><strong>Ctrl + Mouse Wheel:</strong> Zoom in or out centered on the mouse position (If enabled in Options).</li>
                    <li><strong>Ctrl + Delete:</strong> Delete all selected text markers and polygons.</li>
                    <li><strong>Ctrl + a:</strong> Select all visible markers.</li>
                    <li><strong>Ctrl + Click:</strong> Add and remove from/to selection.</li>
                    <li><strong>Ctrl + d:</strong> Deselect all markers.</li>
                    <li><strong>Ctrl + i:</strong> Invert Selection.</li>
                    <li><strong>Ctrl + z:</strong> Undo the last action.</li>
                    <li><strong>Ctrl + y:</strong> Redo the last action.</li>
                    <li><strong>Escape:</strong> Cancel out of draw events.</li>
                </ul>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

  
<!-- Spinner Modal -->
<div class="modal modal-sm" data-bs-backdrop="static" id="spinnerModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-body text-center">
                <p>Loading...</p>
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Confirmation to Overwrite Modal -->
<div class="modal fade" id="confirmOverwriteModal" tabindex="-1" aria-labelledby="confirmOverwriteModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="confirmOverwriteModalLabel">Confirm Overwrite</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body text-center">
                Are you sure you want to overwrite the saved file?
            </div>
            <span class="text-muted text-center text-uppercase text-emphasis-underline">Current UUID:</span>
            <p class="uuid-placeholder text-muted text-center" id="currentGlobalUuid"></p>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">No</button>
                <button type="button" id="confirmOverwriteYes" class="btn btn-primary">Yes</button>
            </div>
        </div>
    </div>
</div>

<!-- Success Modal -->
<div class="modal fade" id="successModal" tabindex="-1" aria-labelledby="successModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="successModalLabel">Success</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <center>
                    <div class="alert alert-success fw-bold m-2" id="successPlaceholder"></div>
                </center>
            </div>
            
            <div class="modal-footer">
                <button type="button" class="btn btn-primary" data-bs-dismiss="modal" id="dismissSuccessModal">OK</button>
            </div>
        </div>
    </div>
</div>

<!-- Load Failure Modal -->
<div class="modal fade" id="failureModal" tabindex="-1" aria-labelledby="failureModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="failureModalLabel">Failure</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <center>
                    <div class="alert alert-danger fw-bold m-2" id="errorPlaceholder"></div>
                </center>
            </div>
            
            <div class="modal-footer">
                <small class="text-muted">Hint: Indecipherable errors tend to indicate network issues</small>
                <button type="button" class="btn btn-primary" data-bs-dismiss="modal">OK</button>
            </div>
        </div>
    </div>
</div>

<!-- Delete Layer Confirmation Modal -->
<div class="modal fade" id="deleteLayerModal" tabindex="-1" aria-labelledby="deleteLayerModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="deleteLayerModalLabel">Delete Layer</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          Are you sure you want to delete this layer: "<span id="layerNamePlaceholder"></span>"?
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
          <button type="button" id="confirmDelete" class="btn btn-danger">Delete</button>
        </div>
      </div>
    </div>
  </div>
  

<!-- Import Modal -->
<div id="dataModal" class="modal">
    <div class="modal-dialog modal-lg">
      <div class="modal-content w-100">
        <div class="modal-header">
          <h5 class="modal-title">Select Data Fields</h5>
          <span class="close-button">&times;</span>
        </div>
        <div class="modal-body">
          <form id="modalForm">
            <div id="dropdowns-container" class="form-group"></div>
            <!-- Divider with label -->
          <div class="py-2">
            <hr class="my-2">
            <p class="text-muted">Additionally, include the following attributes:</p>
          </div>
            <div id="checkboxes-container" class="form-group"></div>
            <div class="alert alert-warning" role="alert">
              <strong>Warning:</strong> Ensure that the latitude and longitude columns are correctly selected to avoid import errors.
            </div>
            <div class="alert alert-info" role="alert">
                <strong>Tip:</strong> If you have a column with team affiliations, include it in the import (check the checkbox) to see the marker's affiliations (See the help menu for more information).
            </div>
            <div class="col m-4">
                <div class="map-option marker-size m-auto w-25 form-control">
                    <h6>Location Jitter</h6>
                    <span id="jitterDisplay">0</span>
                    <input type="range" class="form-jitter" min="0" max="15" value="0" id="customJitter">
                </div>
            </div>
            <button id="submitSelection" type="submit" class="btn btn-primary">Load</button>
          </form>
        </div>
      </div>
    </div>
</div>
<div class="modal fade" id="filtersModal" tabindex="-1" aria-labelledby="filtersModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="filtersModalLabel">Marker Filters</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="row">
                    <div class="col">
                        <div class="show-all-markers mt-4">
                            <button type="button" class="btn btn-sm btn-primary w-75" onclick="showAllMarkers()" id="showAllMarkers"><i class="bi bi-eye icons"></i>Show All</button>
                        </div>
                    </div>
                    <div class="col">
                        <div class="hide-all-markers mt-4">
                            <button type="button" class="btn btn-sm btn-primary w-75" onclick="hideAllMarkers()" id="hideAllMarkers"><i class="bi bi-eye-slash icons"></i>Hide All</button>
                        </div>
                    </div>
                </div>
                
                <div class="row">
                    <div class="col">
                        <div class="map-option country-chooser mt-4 form-control">
                            <h6><i class="bi bi-funnel-fill icons"></i>By Country</h6>
                            <select id="chooser-country" class="form-select" multiple aria-label="multiple select">
                            </select>
                            <button type="button" class="btn btn-sm btn-primary m-2" id="showByCountryBtn">Show Selected</button>
                            <button type="button" class="btn btn-sm btn-primary m-2" id="hideByCountryBtn">Hide Selected</button>
                        </div>
                    </div>
                    
                </div>
                <div class="row">
                    <div class="col">
                        <div class="map-option domain-chooser mt-4 form-control">
                            <h6><i class="bi bi-funnel-fill icons"></i>By Domain</h6>
                            <select id="chooser-domain" class="form-select" multiple aria-label="multiple select">
                            </select>
                            <button type="button" class="btn btn-sm btn-primary m-2" id="showByDomainBtn">Show Selected</button>
                            <button type="button" class="btn btn-sm btn-primary m-2" id="hideByDomainBtn">Hide Selected</button>
                        </div>
                    </div>
                    
                </div>
                <div class="row">
                    <div class="col">
                        <div class="map-option unitType-chooser mt-4 form-control">
                            <h6><i class="bi bi-funnel-fill icons"></i>By Unit Type</h6>
                            <select id="chooser-unitType" class="form-select" multiple aria-label="multiple select">
                            </select>
                            <button type="button" class="btn btn-sm btn-primary m-2" id="showByUnitTypeBtn">Show Selected</button>
                            <button type="button" class="btn btn-sm btn-primary m-2" id="hideByUnitTypeBtn">Hide Selected</button>
                        </div>
                    </div>
                    
                </div>
            </div>
        </div>
    </div>
</div>

<form id="saveMapData" method="post" action="{% url 'save_great_file' %}">
    {% csrf_token %}
</form>

{% csrf_token %}
<script>

// first things first, set the map element size

var mapHeight = "{{ map_height }}";
var mapWidth = "{{ map_width }}";

// if both
if (mapHeight && mapWidth) {
    document.getElementById('map').style.height = mapHeight + 'px';
    document.getElementById('map').style.width = mapWidth + 'px';
    // remove min-width
    document.getElementById('map').style.minWidth = '';
}

    // catch event initDatatableComplete
        
document.addEventListener('initDatatableComplete', function() {
    console.log('Datatable initialized - Event Caught');
    hideSpinnerModal();
    showSuccessModal("File Loaded Successfully");
    
});

// check for this event hide.bs.modal to enforce backdrop removal
{% comment %} document.addEventListener('hide.bs.modal', function() {
    //console.log('Modal hidden - Event Caught');
    $('.modal-backdrop').remove();
}); {% endcomment %}

var baseLayers = {}; // Object to hold country and domain layers
var overlayMaps = {};
var movedMarkers = []; // Array to hold markers that have been moved
var originalMarkers = []; // Array to hold the original positions of markers
var searchableMarkers = [];
var selectedMarkers = []; // Array to hold selected markers
var selectedShapes = []; // Array to hold selected polygons
var selectedTextMarkers = []; // Array to hold selected text markers
var currentMarkers = []; // Array to hold the current markers
var mapDisplayRules = [];
var rangeRingsLayers = [];
var searchableLayer = new L.FeatureGroup();
var savedGeometriesArray = [];
var jsonObjects; // used for data import
var filteredJsonObjects = [];
var globalIconSize = 30; // Set the default icon size
var positionChangeTracker = {};
// Search logic
var fileName;
let currentMarkerIndex = 0; // Track the index of the current marker
var selectionColor = 'magenta'; // Default selection color
var matchedMarkers = []; // Array to hold markers that match the search
var allUnitMarkers = [];
// initialize the map on the "map" div with a given center and zoom

// Base icon size: This is the size of the icon at the base zoom level.
const baseSize = 30; // Change this according to your default icon size.

// Base zoom level: This is the zoom level at which your icons will appear at the base size.
const baseZoomLevel = 13; // Adjust based on your map's typical or initial zoom level.

// Scale factor: This determines how much the icon size should change with each zoom level.
// You may need to adjust this through testing to find a value that works well for your use case.
const scaleFactor = 3; // This means the icon size will increase/decrease by 3 units per zoom level.

// Minimum and maximum size: To prevent the icons from becoming too small or too large.
const minSize = 10; // Minimum size to ensure icons remain visible.
const maxSize = 100; // Maximum size to prevent icons from becoming overwhelmingly large.

var pluginCreationTracker = {};
var canvasRenderer = L.canvas();
map = L.map('map', {
    preferCanvas: true,
    worldCopyJump: true,
    renderer: canvasRenderer,
    zoomSnap: 1,
    zoomDelta: 1,
    zoomAnimation: false,
    fadeAnimation: false,
    wheelPxPerZoomLevel: 100
}).setView([51.505, -0.09], 4);
map.setZoom(2);
map.scrollWheelZoom.enable();
map.on('moveend', updateURL);
map.on('zoomend', updateURL);
// Add a custom wheel event listener to the map's container
map.getContainer().addEventListener('wheel', function(event) {
    if (event.ctrlKey) {
        // Prevent the default behavior
        event.preventDefault();

        // Get the mouse position relative to the map container
        const mousePosition = map.mouseEventToContainerPoint(event);

        // Convert the mouse position to geographical coordinates (lat/lng)
        const zoomCenter = map.containerPointToLatLng(mousePosition);

        // Determine the direction of the scroll and zoom accordingly
        if (event.deltaY < 0) {
            // Zoom in with the mouse position as the center
            map.setZoomAround(zoomCenter, map.getZoom() + 1);
        } else {
            // Zoom out with the mouse position as the center
            map.setZoomAround(zoomCenter, map.getZoom() - 1);
        }
    } else {
        var overlay = document.getElementById('zoomOverlay');
        if (overlay && mouseWheelState == false) {
            overlay.style.display = 'block';
            setTimeout(function() {
                overlay.style.display = 'none';
            }, 7000);
        }
    }
}, { passive: false }); // Ensure preventDefault() works

L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
    maxZoom: 19,
    useCache: true,
    edgeBufferTiles: 10,
    cacheMaxAge: 259200000,
    detectRetina: true,
    
    attribution: 'Tiles &copy; Esri &mdash; Source: Esri'
}).addTo(map);

// Initialize Leaflet.BigImage
var bigImage = L.control.bigImage(map, {
    position: 'topright',
});
bigImage.addTo(map);

window.addEventListener('load', function() {
    if (window.location.hash) {
        var hash = window.location.hash.substring(1); // remove '#'
        var params = new URLSearchParams(hash);
        var lat = parseFloat(params.get('lat'));
        var lng = parseFloat(params.get('lng'));
        var zoom = parseInt(params.get('zoom'), 10);

        if (!isNaN(lat) && !isNaN(lng) && !isNaN(zoom)) {
            map.setView([lat, lng], zoom);
        }
    }
});

// Update the display as the weight slider's value changes
customJitter.addEventListener('input', function() {
    jitterDisplay.innerText = this.value;
});

var kmlBaseLayers = {};
var kmlOverlays = {}; // Object to hold your KML layers
var currentLineWeight = 1;
var currentFontSize = 14;

function updateURL() {
    var center = map.getCenter();
    var zoom = map.getZoom();
    // Round the coordinates for cleaner URLs
    var lat = center.lat.toFixed(5);
    var lng = center.lng.toFixed(5);

    // Update the window hash with lat, lng, zoom
    // Format: #lat=...&lng=...&zoom=...
    window.location.hash = `lat=${lat}&lng=${lng}&zoom=${zoom}`;
}


function initKMLPlugin() {
    kmlFiles = [
        "{% static '/files/scenario/share/Railroads.kml' %}",
        "{% static '/files/scenario/share/WorldBorders.kml' %}",
        "{% static '/files/scenario/share/CableMap.kml' %}",
        "{% static '/files/scenario/share/WorldLabels.kml' %}",
        //"{% static '/files/scenario/share/Global_Oil_Gas.kml' %}",
    ];

    kmlFiles.forEach(function (kmlFile) {
        let kmlLayer; // Declare the variable outside the try-catch block for scope
    
        try {
            kmlLayer = omnivore.kml(kmlFile, null, L.geoJson(null, {
                style: function (feature) {
                    return {
                        color: "red",
                        weight: currentLineWeight,
                        fillColor: "transparent",
                        fillOpacity: 0,                        
                        isKML: true
                    };
                },
                pointToLayer: function (feature, latlng) {
                    //console.log(feature.properties.name);
                    return L.marker(latlng, {
                        icon: L.divIcon({
                            className: 'country-label',
                            html: '<span class="kml-style" style="color: red; font-weight: bold; font-size:' + currentFontSize + 'px;">' +
                                (feature.properties && feature.properties.name ? feature.properties.name : '') +
                                '</span>',
                            
                        }),
                        isKML: true
                    });
                }
            }));
        } catch (e) {
            console.error(`Error loading KML file: ${kmlFile}`);
            console.error(e.message);
            // Skip to the next file
            return;
        }
    
        let filename = kmlFile.split('/').pop().split('.').slice(0, -1).join('.');
        kmlOverlays[filename] = kmlLayer;
    });
    

    // Create a custom control similar to the TileLayerSwitcher
    L.Control.KmlLayerSwitcher = L.Control.extend({
        onAdd: function(map) {
            var div = L.DomUtil.create('div', 'kml-layer-switcher');
            L.DomEvent.disableClickPropagation(div);

            // Create the dropdown container
            var dropdown = L.DomUtil.create('div', 'dropdown-container', div);

            // Create the dropdown button
            var dropdownButton = L.DomUtil.create('button', '', dropdown);
            dropdownButton.innerHTML = '<i class="bi bi-layers-fill icons"></i>KML Layers';

            // Style the dropdown button
            dropdown.style.position = 'relative';
            dropdownButton.style.cursor = 'pointer';
            dropdownButton.style.padding = '5px 10px';
            dropdownButton.style.background = '#fff';
            dropdownButton.style.border = '1px solid #ccc';
            dropdownButton.style.borderRadius = '4px';
            dropdownButton.style.whiteSpace = 'nowrap';
            dropdownButton.style.fontSize = '12px';

            // Create the dropdown content container
            var dropdownContent = L.DomUtil.create('div', 'dropdown-content', dropdown);
            dropdownContent.style.display = 'none'; // Initially hidden
            dropdownContent.style.position = 'absolute';
            dropdownContent.style.backgroundColor = '#fff';
            dropdownContent.style.minWidth = '160px';
            dropdownContent.style.border = '1px solid #ccc';
            dropdownContent.style.boxShadow = '0px 8px 16px rgba(0,0,0,0.2)';
            dropdownContent.style.zIndex = '9000';
            dropdownContent.style.padding = '5px';
            dropdownContent.style.top = '0%';
            dropdownContent.style.left = '-160%';

            // Scrollable if many KML layers
            dropdownContent.style.maxHeight = '200px';
            dropdownContent.style.overflowY = 'auto';

            // Add KML layer checkboxes and colorpickers
            Object.keys(kmlOverlays).forEach(function(name) {
                var label = L.DomUtil.create('label', '', dropdownContent);
                label.style.display = 'block';
                label.style.padding = '2px 5px';

                var input = L.DomUtil.create('input', '', label);
                input.type = 'checkbox';
                input.value = name;
                input.defaultChecked = false;
                label.appendChild(document.createTextNode(' ' + name));

                // Create a color input
                var colorInput = L.DomUtil.create('input', 'kml-color-picker', label);
                colorInput.type = 'color';
                colorInput.value = '#ff0000'; // default color
                colorInput.style.marginLeft = '5px';
                colorInput.style.width = '30px';
                colorInput.style.height = '15px';
                colorInput.style.float = 'right';

                // Toggle KML layers when checkbox changes
                L.DomEvent.on(input, 'change', function(e) {
                    var layer = kmlOverlays[e.target.value];
                    if (e.target.checked) {
                        map.addLayer(layer);
                    } else {
                        map.removeLayer(layer);
                    }
                });

                // Update layer color when color input changes
                L.DomEvent.on(colorInput, 'input', function(e) {
                    var newColor = e.target.value;
                    var layer = kmlOverlays[name];
                    // Assuming layer is L.geoJson and supports setStyle
                    layer.setStyle({color: newColor});
                    // Also update the label text color if needed
                    var spans = layer.getLayers().filter(l => l instanceof L.Marker).map(l => l._icon.querySelector('.kml-style'));
                    spans.forEach(span => {
                        span.style.color = newColor;
                    });
                });
            });

            // Add thickness and font controls
            var toolsDiv = L.DomUtil.create('div', 'line-font-control', dropdownContent);
            toolsDiv.style.marginTop = '10px';
            toolsDiv.style.borderTop = '1px solid #ccc';
            toolsDiv.style.paddingTop = '5px';
            toolsDiv.innerHTML = `
              <div>
                <strong>Line Thickness:</strong><br/>
                <i class="bi bi-plus-square" style="cursor:pointer;" onclick="modifyLineThickness('increase')"></i>
                <i class="bi bi-dash-square" style="cursor:pointer; margin-left:5px;" onclick="modifyLineThickness('decrease')"></i>
              </div>
              <div style="margin-top:10px;">
                <strong>Font Size:</strong><br/>
                <i class="bi bi-plus-square" style="cursor:pointer;" onclick="modifyLabelFontSize('increase')"></i>
                <i class="bi bi-dash-square" style="cursor:pointer; margin-left:5px;" onclick="modifyLabelFontSize('decrease')"></i>
              </div>
            `;

            // Toggle the dropdown visibility on button click
            L.DomEvent.on(dropdownButton, 'click', function() {
                dropdownContent.style.display = dropdownContent.style.display === 'block' ? 'none' : 'block';
            });

            // Clicking outside closes the dropdown
            document.addEventListener('click', function(e) {
                if (!div.contains(e.target)) {
                    dropdownContent.style.display = 'none';
                }
            });

            // Prevent map interactions when scrolling inside the dropdown
            L.DomEvent.on(dropdownContent, 'wheel', function(e) {
                L.DomEvent.stopPropagation(e);
            });

            return div;
        }
    });

    var kmlLayerSwitcher = new L.Control.KmlLayerSwitcher({ position: 'topright' }).addTo(map);
}





function modifyLineThickness(action) {
    if (action === "increase") {
        currentLineWeight += 1;
    } else if (action === "decrease" && currentLineWeight > 1) {
        currentLineWeight -= 1;
    }

    for (var key in kmlOverlays) {
        if (kmlOverlays.hasOwnProperty(key)) {
            kmlOverlays[key].setStyle({ weight: currentLineWeight });
        }
    }
}

function modifyLabelFontSize(action) {
    if (action === "increase") {
        currentFontSize += 2;
    } else if (action === "decrease" && currentFontSize > 8) {
        currentFontSize -= 2;
    }

    var labelElements = document.querySelectorAll('.country-label span');
    labelElements.forEach(function(el) {
        el.style.fontSize = currentFontSize + 'px';
    });
}




initKMLPlugin();

function downloadArmyGix() {
    // Static URL of the file
    var url = "{% static 'media/wiki/attachments/22/a9f462f5ebd91280f2cb1cebb86c961b/Military_Symbol_Update_4-2023_V2.pptx' %}";
    
    // Create a temporary anchor element
    var a = document.createElement('a');
    // Set the href of the anchor to the file URL
    a.href = url;
    // Append the anchor to the body (required for some browsers)
    document.body.appendChild(a);
    // Simulate a click on the anchor to trigger the download
    a.click();
    // Remove the anchor from the document
    document.body.removeChild(a);
}

function refreshUniqueIDs() {
    // check if datatable exists
    if (!dataTable) {
        console.error('Data table not found');
        return;
    }
    
    // Generate a new unique ID for each marker
    map.eachLayer(function(layer) {
        if (layer instanceof L.Marker && layer.options.unique_id) {
            const uniqueID = generateUniqueID();
            layer.options.unique_id = uniqueID;
            layer.options.dataTable['unique_id'] = uniqueID;
            var popupContent = buildPopupContent(layer, uniqueID);
            layer.options.details = popupContent;
            //console.log('New unique ID: ' + uniqueID);
            //console.log('New popup content: ' + popupContent);
        }
    });
    // Redraw the data table
    initDatatable();

    console.log('Unique IDs refreshed');
}

function updateMarkerStyle(isSelected, marker) {
    // Ensure the marker and its icon element are valid
    if (marker && marker._icon) {
        if (isSelected) {
            // Add the 'selected-marker' class to outline the marker
            marker._icon.classList.add('selected-marker-color')
        } else {
            // Remove the 'selected-marker' class to remove the outline            
            marker._icon.classList.remove('selected-marker-color');
        }
    }
}


function updateShapeStyle(isSelected, polygon) {
    // Initialize originalStyle if it doesn't exist
    if (!polygon.options.originalStyle) {
        polygon.options.originalStyle = {
            color: polygon.options.color || (polygon.pm && polygon.pm.options.color) || (polygon.pm && polygon.pm.options.hintlineStyle && polygon.pm.options.hintlineStyle.color) || 'blue', // default fallback
            fillColor: polygon.options.fillColor || (polygon.pm && polygon.pm.options.fillColor) || (polygon.pm && polygon.pm.options.hintlineStyle && polygon.pm.options.hintlineStyle.fillColor) || 'blue', // default fallback
            dashArray: polygon.options.dashArray || null // default fallback
        };
    }

    // Check if the polygon layer exists
    if (polygon.pm && polygon.pm._layer) {
        if (isSelected) {
            // Apply selected style
            polygon.setStyle({
                color: 'magenta',           // Change outline color
                dashArray: '5 5',           // Add dashed outline
                fillColor: polygon.options.originalStyle.fillColor // Keep original fill color
            });
        } else {
            // Revert to original style
            polygon.setStyle({
                color: polygon.options.originalStyle.color,         // Restore original outline color
                dashArray: polygon.options.originalStyle.dashArray, // Restore original dash array
                fillColor: polygon.options.originalStyle.color   // Restore original fill color
            });
            // Remove the stored originalStyle to free up memory
            delete polygon.options.originalStyle;
        }
    }
}


var iconSizeFactor = 1;     // icon size factor
var iconOpacity = 0;        // icon opacity
var iconSelectionHighlight = '#FF00FF'; // Default selection color  
document.getElementById('markerSize').addEventListener('input', function() {
    var value = this.value; 
    document.getElementById('rangeValue').textContent = value;
    iconSizeFactor = 1 + value/10;
    reDrawMarkers();
});

// on change colorPicker
document.getElementById('colorPicker').addEventListener('input', function() {
    document.documentElement.style.setProperty('--selectedMarkerColor', this.value);
    //console.log(getComputedStyle(document.documentElement).getPropertyValue('--selectedMarkerColor'));
});

function changeRangeRingsSelection(newValue) {
    var select = document.getElementById('rangeRingsSwitcherSelect');
    if (!select) {
        console.error('Range Rings Switcher select element not found');
        return;
    }
    
    // Update the select value
    select.value = newValue;
    
    // Manually trigger the 'change' event on the select element
    var event = new Event('change', { bubbles: true });
    select.dispatchEvent(event);
}


function reDrawMarkers(){
    //console.log("Redrawing Markers");
    map.eachLayer(function(layer) {
        if (layer instanceof L.Marker) {
            newSize = calculateIconSize(map.getZoom());
            var newIcon = L.icon({
                iconUrl: layer.options.icon.options.iconUrl, // Reuse the current icon URL
                iconSize: [newSize, newSize], // Set the new size
                iconAnchor: [newSize / 2, newSize / 2] // Adjust anchor point accordingly
            });
            layer.setIcon(newIcon);
            if (layer.options.health == 0) {
                layer.setOpacity(iconOpacity);
            }
        }
    });
}
var importFileName;
function importData() {
    // Prompt user to select a file
    var fileInput = document.createElement('input');
    
    fileInput.type = 'file';
    fileInput.accept = '.xlsx';
    fileInput.click();

    // Convert the file to JSON "dicts" to maintain key-value pairings
    fileInput.addEventListener('change', function(e) {
        var file = e.target.files[0];
        // get filename
        importFileName = file.name;
        var reader = new FileReader();
        reader.onload = function(e) {
            var data = new Uint8Array(e.target.result);
            var workbook = XLSX.read(data, {type: 'array'});
            var firstSheetName = workbook.SheetNames[0];
            var worksheet = workbook.Sheets[firstSheetName];
            // Convert sheet to JSON objects using the first row as headers
            jsonObjects = XLSX.utils.sheet_to_json(worksheet, {raw: true});
            //console.log(jsonObjects);
            
            if (jsonObjects.length > 0) {
                const keys = Object.keys(jsonObjects[0]);
                populateModal(keys);
                showModal();
            }
                
        };
        reader.readAsArrayBuffer(file);
    });
    fixAntimeridianMarkers();

    
}

function loadSavedFile() {
    // Correctly create a file input element
    var fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.great';

    fileInput.addEventListener('change', function(event) {
        // Get the file name from the file input
        fileName = '';
        if(fileInput.files.length > 0) {
            // Get the name of the first selected file
            fileName = fileInput.files[0].name;
        }
        console.log("Importing file: " + fileName);
    });

    // Trigger the file input click action
    fileInput.click();
    
    

    // Add change event listener to process the selected file
    fileInput.addEventListener('change', function(e) {
        var file = e.target.files[0];
        var reader = new FileReader();

        // Define the onload event handler for the FileReader
        reader.onload = function(event) {
            loadSavedMapData(event.target.result);
        };
        if (file) {
            reader.readAsText(file);
        } else {
            console.error('No file selected');
        }

        
    });
}

function loadSavedMapData(jsonData){
    showSpinnerModal();
    console.log("Parsing file...");
    try {
        const mapData = JSON.parse(jsonData);
        console.log("File parsed successfully");
        console.log(mapData);
        if (mapData.markers) {
            mapData.markers.forEach(function(markerData) {
                
                if (markerData.type == "Marker" && markerData.options.textMarker !== true) {
                

                    let markerOptions = { ...markerData.options };

                    // Check if icon options are present and correctly instantiate the icon if they are

                    if (markerData.options.icon && markerData.options.icon.options) {
                        markerOptions.icon = L.icon({
                            ...markerData.options.icon.options,
                        });
                    }
            
                    // Create a new marker with the processed options
                    var marker = L.marker(markerData.latLng, markerOptions);

                    // if marker was rotated it will have a rotation property
                    if ('rotation' in markerData.options) {
                        marker.setRotationAngle(markerData.options.rotationAngle);
                    }


                    // this is an interim fix to support .great file compatibility with the added filter features
                    // 'domain' was not a marker.options attribute before this addition
                    // does this key exist markerData.options.dataTable.Domain
                    //console.log(markerData.options.dataTable);
                    if ('Domain' in markerData.options.dataTable) {
                        marker.options.domain = markerData.options.dataTable.Domain;
                    }

                    // set the start_latitude and start_longitude to current latitude and longitude - this is because the .great files are previous saves and 
                    // the point of origin should start from the current location
                    marker.options.start_latitude = markerData.latLng.lat;
                    marker.options.start_longitude = markerData.latLng.lng;
                    
                    // Check if the country layer exists, if not create it
                    if (!baseLayers[fileName]) {
                        console.log("Creating Layer: " + fileName);
                        baseLayers[fileName] = L.layerGroup().addTo(map);
                    }
                    //addToLayer(fileName, marker);
                    
                    // Add the marker to the map
                    //marker.addTo(map);
            
                    // Bind a popup to the marker if specified
                    if (markerData.options.popup) {
                        marker.bindPopup(markerData.options.popup);
                    }
                    
                    allUnitMarkers.push(marker);
                    marker.addTo(baseLayers[fileName]);

                    // Assuming searchableLayer and searchableMarkers are defined and intended for further use
                    searchableLayer.addLayer(marker);
                    searchableMarkers.push(marker);
            
                    // Assuming setupMarkerHandlers is a function defined elsewhere to set up event handlers for the marker
                    setupMarkerHandlers(marker, true);
                    
                    // Assuming originalMarkers is an array intended to keep track of all original markers
                    originalMarkers.push(marker);

                    // add marker.options.attached_polygons to the marker
                    marker.options.attached_polygons = [];
                    processRangeRings(marker);
                    addMarkerContextMenu(marker);

                    // process layers
                    if (marker.options.assignedLayers) {
                        marker.options.assignedLayers.forEach(function(layerName) {
                            addToLayer(layerName, marker);
                        });
                    } else {
                        addToLayer(fileName, marker);
                    }
                } else if (markerData.type == "Marker" && markerData.options.textMarker == true) {
                    // Create a new text marker with the processed options
                    var textMarker = L.marker(markerData.latLng, markerData.options).addTo(baseLayers[fileName]);
                    textMarker.on('click', function(e) {
                        // prevent propagation
                        L.DomEvent.stopPropagation(e);
                        toggleMarkerSelection(e);
                    });
                    // process layers
                    if (textMarker.options.assignedLayers) {
                        textMarker.options.assignedLayers.forEach(function(layerName) {
                            addToLayer(layerName, textMarker);
                        });
                    } else {
                        addToLayer(fileName, textMarker);
                    }
                }

            });
            if (pluginCreationTracker['CustomToolbar_Plugin'] != true) {
                initControlCustomToolbar();
            }
            if (pluginCreationTracker['LogRings_Plugin'] != true) {
                initLogRingsPlugin();
            }
            if (pluginCreationTracker['RangeRings_Plugin'] != true) {
                initRangeRingsPlugin();
            }
        }
        // Add other layers (generic handling)
        if (mapData.otherLayers) {
            console.log("Adding other poly layers...");
            if (!baseLayers[fileName]) {
                console.log("Creating Layer: " + fileName);
                baseLayers[fileName] = L.layerGroup().addTo(map);
            }
            mapData.otherLayers.forEach(function(layerData) {
                let layer;
                var clickTimeout;
                switch(layerData.shape) {
                    case 'Rectangle':
                        // Assumes the southwest and northeast corners are the first and third points, respectively
                        if (layerData.latLngs && layerData.latLngs[0].length === 4) {
                            var bounds = [
                                [layerData.latLngs[0][0].lat, layerData.latLngs[0][0].lng],
                                [layerData.latLngs[0][2].lat, layerData.latLngs[0][2].lng]
                            ];
                            layer = L.rectangle(bounds, layerData.options).addTo(baseLayers[fileName]);
                            layer.options.shape = layerData.shape;
                            layer.on('dblclick', function(e) {
                                L.DomEvent.stopPropagation(e);
    
                                // Clear the click timeout to prevent the single click action
                                if (clickTimeout) {
                                    clearTimeout(clickTimeout);
                                    clickTimeout = null;
                                }

                                var colorPicker = document.getElementById('color-picker');
                                if (colorPicker) {
                                    layer.setStyle({ color: colorPicker.value, fill: colorPicker.value });
                                }
                            });
                            layer.on('click', function(e) {
                                // Clear any existing timeout to avoid double handling
                                if (clickTimeout) {
                                    clearTimeout(clickTimeout);
                                }
                        
                                // Set a timeout for the single click action
                                clickTimeout = setTimeout(function() {
                                    // prevent propagation
                                    L.DomEvent.stopPropagation(e);
                                    toggleShapeSelection(e);
                                }, 200); // Adjust the delay time as needed
                            });
                        }
                        break;
                    case 'Circle':
                        // Assumes latLng for the center and a radius option are provided
                        if (layerData.latLng && layerData.options.radius) {
                            layer = L.circle(layerData.latLng, layerData.options).addTo(baseLayers[fileName]);
                            layer.options.shape = layerData.shape;
                            layer.on('dblclick', function(e) {
                                L.DomEvent.stopPropagation(e);
    
                                // Clear the click timeout to prevent the single click action
                                if (clickTimeout) {
                                    clearTimeout(clickTimeout);
                                    clickTimeout = null;
                                }

                                var colorPicker = document.getElementById('color-picker');
                                if (colorPicker) {
                                    layer.setStyle({ color: colorPicker.value, fill: colorPicker.value });
                                }
                            });
                            layer.on('click', function(e) {
                                // Clear any existing timeout to avoid double handling
                                if (clickTimeout) {
                                    clearTimeout(clickTimeout);
                                }
                        
                                // Set a timeout for the single click action
                                clickTimeout = setTimeout(function() {
                                    // prevent propagation
                                    L.DomEvent.stopPropagation(e);
                                    toggleShapeSelection(e);
                                }, 200); // Adjust the delay time as needed
                            });
                        }
                        break;
                    case 'Polygon':
                        // Assumes latLngs is an array of arrays of points
                        if (layerData.latLngs) {
                            layerData.latLngs.forEach(function(polygonPoints) {
                                layer = L.polygon(polygonPoints, layerData.options).addTo(baseLayers[fileName]);
                                layer.options.shape = layerData.shape;
                                layer.on('dblclick', function(e) {
                                    L.DomEvent.stopPropagation(e);
        
                                    // Clear the click timeout to prevent the single click action
                                    if (clickTimeout) {
                                        clearTimeout(clickTimeout);
                                        clickTimeout = null;
                                    }
    
                                    var colorPicker = document.getElementById('color-picker');
                                    if (colorPicker) {
                                        layer.setStyle({ color: colorPicker.value, fill: colorPicker.value });
                                    }
                                });
                                layer.on('click', function(e) {
                                    // Clear any existing timeout to avoid double handling
                                    if (clickTimeout) {
                                        clearTimeout(clickTimeout);
                                    }
                            
                                    // Set a timeout for the single click action
                                    clickTimeout = setTimeout(function() {
                                        // prevent propagation
                                        L.DomEvent.stopPropagation(e);
                                        toggleShapeSelection(e);
                                    }, 200); // Adjust the delay time as needed
                                });
                            });
                        }
                        break;
                    case 'Polyline':
                        // Assumes latLngs is an array of points
                        if (layerData.latLngs) {
                            layerData.latLngs.forEach(function(polylinePoints) {
                                layer = L.polyline(polylinePoints, layerData.options).addTo(baseLayers[fileName]);
                                layer.options.shape = layerData.shape;
                                layer.on('dblclick', function(e) {
                                    L.DomEvent.stopPropagation(e);
        
                                    // Clear the click timeout to prevent the single click action
                                    if (clickTimeout) {
                                        clearTimeout(clickTimeout);
                                        clickTimeout = null;
                                    }
    
                                    var colorPicker = document.getElementById('color-picker');
                                    if (colorPicker) {
                                        layer.setStyle({ color: colorPicker.value});
                                    }
                                });
                                layer.on('click', function(e) {
                                    // Clear any existing timeout to avoid double handling
                                    if (clickTimeout) {
                                        clearTimeout(clickTimeout);
                                    }
                            
                                    // Set a timeout for the single click action
                                    clickTimeout = setTimeout(function() {
                                        // prevent propagation
                                        L.DomEvent.stopPropagation(e);
                                        toggleShapeSelection(e);
                                    }, 200); // Adjust the delay time as needed
                                });
                            });
                        }
                        break;
                    case 'Line':
                        if (layerData.latLngs) {
                            const polyPoints = layerData.latLngs.map(point => [point.lat, point.lng]);
                            //console.log(polyPoints);
                            layer = L.polyline(polyPoints, 
                                { ...layerData.options,
                                    fill: false,
                                });
                            layer.options.shape = layerData.shape;
                            layer.addTo(baseLayers[fileName]);
                            layer.on('dblclick', function(e) {
                                L.DomEvent.stopPropagation(e);
    
                                // Clear the click timeout to prevent the single click action
                                if (clickTimeout) {
                                    clearTimeout(clickTimeout);
                                    clickTimeout = null;
                                }

                                var colorPicker = document.getElementById('color-picker');
                                if (colorPicker) {
                                    layer.setStyle({ color: colorPicker.value});
                                }
                            });
                            layer.on('click', function(e) {
                                // Clear any existing timeout to avoid double handling
                                if (clickTimeout) {
                                    clearTimeout(clickTimeout);
                                }
                        
                                // Set a timeout for the single click action
                                clickTimeout = setTimeout(function() {
                                    // prevent propagation
                                    L.DomEvent.stopPropagation(e);
                                    toggleShapeSelection(e);
                                }, 200); // Adjust the delay time as needed
                            });
                            
                        }
                        break;
                    case 'CustomLine':
                        // Assumes latLngs is an array of points
                        if (layerData.latLngs) {
                            const polyPoints = layerData.latLngs.map(point => [point.lat, point.lng]);
                            //console.log(polyPoints);
                            layer = L.polyline(polyPoints, 
                                { ...layerData.options,
                                    fill: false,
                                });
                            layer.options.shape = layerData.shape;
                            layer.addTo(baseLayers[fileName]);
                            layer.on('dblclick', function(e) {
                                L.DomEvent.stopPropagation(e);
    
                                // Clear the click timeout to prevent the single click action
                                if (clickTimeout) {
                                    clearTimeout(clickTimeout);
                                    clickTimeout = null;
                                }

                                var colorPicker = document.getElementById('color-picker');
                                if (colorPicker) {
                                    layer.setStyle({ color: colorPicker.value});
                                }
                            });
                            layer.on('click', function(e) {
                                // Clear any existing timeout to avoid double handling
                                if (clickTimeout) {
                                    clearTimeout(clickTimeout);
                                }
                        
                                // Set a timeout for the single click action
                                clickTimeout = setTimeout(function() {
                                    // prevent propagation
                                    L.DomEvent.stopPropagation(e);
                                    toggleShapeSelection(e);
                                }, 200); // Adjust the delay time as needed
                            });
                            
                        }
                        break;
                    case 'CircleMarker':
                    // Assumes latLng for the center is provided
                        if (layerData.latLng) {
                            layer = L.circleMarker(layerData.latLng, layerData.options).addTo(baseLayers[fileName]);
                            layer.options.shape = layerData.shape;
                            layer.on('dblclick', function(e) {
                                L.DomEvent.stopPropagation(e);
    
                                // Clear the click timeout to prevent the single click action
                                if (clickTimeout) {
                                    clearTimeout(clickTimeout);
                                    clickTimeout = null;
                                }

                                var colorPicker = document.getElementById('color-picker');
                                if (colorPicker) {
                                    layer.setStyle({ color: colorPicker.value, fill: colorPicker.value });
                                }
                            });
                            layer.on('click', function(e) {
                                // Clear any existing timeout to avoid double handling
                                if (clickTimeout) {
                                    clearTimeout(clickTimeout);
                                }
                        
                                // Set a timeout for the single click action
                                clickTimeout = setTimeout(function() {
                                    // prevent propagation
                                    L.DomEvent.stopPropagation(e);
                                    toggleShapeSelection(e);
                                }, 200); // Adjust the delay time as needed
                            });
                        }
                    break;
                }
                if (layer.options.assignedLayers) {
                    layer.options.assignedLayers.forEach(function(layerName) {
                        addToLayer(layerName, layer);
                    });
                } else {
                    addToLayer(fileName, layer);
                }
            });
            
            
        }


        for (var key in baseLayers) {
            overlayMaps[key] = baseLayers[key];
        }
        //updateControlLayer(overlayMaps);
        fixAntimeridianMarkers();
        initLRFPlugin();
        initPointofOriginPlugin();
        synchronizeLayersVisibility();
        //initLayerDisplayPlugin();
        initLayerMgmtPlugin();
        initDatatable();

        hideSpinnerModal();
        showSuccessModal("File Loaded Successfully");

    } catch (error) {
        hideSpinnerModal();
        console.error('Error loading map data:', error);
        //alert('Failed to load map data. Please ensure the file is a valid JSON format.');
        showFailureModal("Failed to load map data. Please see the console logs.");
    }
    
}

const spinnerModal = new bootstrap.Modal(document.getElementById('spinnerModal'), {
    backdrop: 'static'
});

// Function to show the spinner modal
function showSpinnerModal() {
    //console.log('Showing spinner modal');
    spinnerModal.show();
    //console.log('Spinner modal shown');
}

// Function to hide the spinner modal
function hideSpinnerModal() {
    //console.log('Hiding spinner modal');
    spinnerModal.hide();
    $('.modal-backdrop').remove();
    //console.log('Spinner modal hidden');
}

function showSuccessModal(successMessage) {
    // add uuid to success modal
    document.getElementById('successPlaceholder').textContent = successMessage;
    var successModal = new bootstrap.Modal(document.getElementById('successModal'));
    successModal.show();
    //console.log('Showing success modal');
}


function showFailureModal(errorMessage) {
    // Update the error placeholder with the actual error message
    document.getElementById('errorPlaceholder').textContent = errorMessage;
    // Show the modal
    var failureModal = new bootstrap.Modal(document.getElementById('failureModal'));
    failureModal.show();
}


function toggleLayerVisibility(layerName) {
    if (globalLayerAssignments[layerName]) {
        if (globalLayerAssignments[layerName].visible) {
            console.log('Hiding layer: ' + layerName);
            hideMarkersByLayerName(layerName);
            hidePolygonsByLayerName(layerName);
            hideTextMarkersByLayerName(layerName);
        } else {
            console.log('Showing layer: ' + layerName);
            showMarkersByLayerName(layerName);
            showPolygonsByLayerName(layerName);
            showTextMarkersByLayerName(layerName);
        }
        // Toggle the visibility flag
    }
}


function initLayerDisplayPlugin() {
    if (pluginCreationTracker['LayerMgmt_Plugin']) {
        console.log('Layer Management Plugin already initialized');
        return;
    }
    // this control will allow the user to toggle the visibility/display of layers
    var LayerMgmtControl = L.Control.extend({
        onAdd: function(map) {
            // Create the container for the control
            var container = L.DomUtil.create('div', 'layer-mgmt-control leaflet-custom-control leaflet-custom-button');
            L.DomEvent.disableClickPropagation(container);
            // Create the button that triggers the dropdown
            var div = L.DomUtil.create('div', 'dropdown', container);
            var button = L.DomUtil.create('a', 'layer-display-dropdown-button leaflet-custom-button', div);
            button.innerHTML = '';  // Assuming you have an SVG background or icon set via CSS

            // Build the dropdown content container
            var dropdownContent = L.DomUtil.create('div', 'layer-mgmt-content', container);
            dropdownContent.style.overflowY = 'auto';
            dropdownContent.style.maxHeight = '9rem';
            dropdownContent.style.display = 'none';
            dropdownContent.style.position = 'absolute';
            dropdownContent.style.backgroundColor = '#fff';
            dropdownContent.style.border = '1px solid #ccc';
            dropdownContent.style.boxShadow = '0px 8px 16px 0px rgba(0,0,0,0.2)';
            dropdownContent.style.zIndex = '9000';
            dropdownContent.style.padding = '10px';
            dropdownContent.style.top = '0%';  // Position below the button
            dropdownContent.style.right = '115%';
            dropdownContent.style.minWidth = 'max-content';

            // Handle button click to toggle dropdown visibility
            L.DomEvent.on(button, 'click', function(e) {
                L.DomEvent.stopPropagation(e);
                L.DomEvent.preventDefault(e);
                

                console.log('Layer Management Button Clicked');

                // Toggle visibility of the dropdown content
                dropdownContent.style.display = dropdownContent.style.display === 'none' ? 'block' : 'none';

                

                // Clear the dropdown content before repopulating
                dropdownContent.innerHTML = '';

                // Populate the dropdown with checkboxes for each layer if available
                if (Object.keys(globalLayerAssignments).length > 0) {
                    Object.keys(globalLayerAssignments).forEach(function(layerName) {
                        var label = L.DomUtil.create('label', 'd-block', dropdownContent);
                        var checkbox = L.DomUtil.create('input', '', label);
                        checkbox.type = 'checkbox';
                        checkbox.value = layerName;
                        checkbox.checked = globalLayerAssignments[layerName].visible;
                        checkbox.style.marginRight = '5px';
                        checkbox.addClassName = 'checkbox-' + layerName;
                        label.appendChild(document.createTextNode(layerName));

                        // Set the initial checkbox state based on layer visibility
                        checkbox.checked = isLayerVisible(layerName);      
                        
                        // add count
                        const className = `${layerName}-sum`
                        const countPara = L.DomUtil.create('p', `${className} d-inline`, label);
                        countPara.innerHTML = ` (${sumMarkersByLayerName(layerName)})`;
                        countPara.style.color = 'grey';
                        countPara.style.marginLeft = '2px';

                        // Handle the layer toggle to show or hide the layer
                        L.DomEvent.on(checkbox, 'change', function(e) {
                            L.DomEvent.stopPropagation(e);
                            L.DomEvent.preventDefault(e);
                            //console.log('Layer "' + layerName + '" is visible: ' + checkbox.checked);
                            toggleLayerVisibility(e.target.value);

                        });
                    });
                }
            });

            // Close the dropdown if clicked outside
            L.DomEvent.on(document, 'click', function(e) {
                if (dropdownContent.style.display === 'block' && !container.contains(e.target)) {
                    dropdownContent.style.display = 'none';
                }
            });

            // Return the container element to add it to the map
            return container;
        }
    });

    // Create and add the control to the map
    var layerMgmtControl = new LayerMgmtControl({ position: 'topright' });
    map.addControl(layerMgmtControl);
    //var layerMgmtControl = new LayerMgmtControl();
    //document.getElementById('custom-toolbar').appendChild(layerMgmtControl.onAdd(map));
    pluginCreationTracker['LayerMgmt_Plugin'] = true;
}

function sumMarkersByLayerName(layerName) {
    if (globalLayerAssignments[layerName]) {
        const { markers, polygons, textMarkers } = globalLayerAssignments[layerName];
        const sum = markers.length + polygons.length + textMarkers.length;
        return sum;
    }
    return 0;
}

// Custom Layer Management Plugin
function initLayerMgmtPlugin() {
    if (pluginCreationTracker['LayerMgmt_Plugin']) {
        console.log('AddLayer Plugin already initialized');
        return;
    }

    function drawLayerSelections(dropdownContent) {
        // Clear the dropdown content before repopulating
        dropdownContent.innerHTML = '';

        // Populate the dropdown with checkboxes for each layer if available
        Object.keys(globalLayerAssignments).forEach(function(layerName) {
            var div = L.DomUtil.create('div', 'd-block', dropdownContent);
            div.style.marginTop = '1px';
            // scrollable
            dropdownContent.style.overflowY = 'auto';
            dropdownContent.style.height = '9rem';
            dropdownContent.style.maxHeight = '15rem';
            dropdownContent.style.resize = 'auto';
            //var checkbox = L.DomUtil.create('input', '', label);

            // create select icon to select layer
            var selectIcon = L.DomUtil.create('i', 'bi bi-arrow-up-left-square m-1', div);
            

            // Create a checkbox for each layer
            var checkbox = L.DomUtil.create('input', '', div);
            checkbox.type = 'checkbox';
            checkbox.value = layerName;
            checkbox.className = 'checkbox-' + layerName + ' form-check-input me-1';
            checkbox.checked = isLayerVisible(layerName);

            
            // remove items from the layer
            const minusBtn = L.DomUtil.create('button', 'minus-btn btn btn-sm btn-outline-danger', div);
            minusBtn.style.padding = '2px 4px';  // Reduce padding to make the button smaller
            minusBtn.style.fontSize = '12px';    // Decrease font size to make the button smaller
            minusBtn.style.lineHeight = '1px';     // Ensure line height doesn't affect icon centering
            //minusBtn.style.marginRight = '5px';
            const minus = L.DomUtil.create('i', 'bi bi-dash-circle', minusBtn);
            minus.style.fontSize = '14px';

                        
            // button to add markers to layer
            const plusBtn = L.DomUtil.create('button', 'plus-btn btn btn-sm btn-outline-success', div);
            plusBtn.style.padding = '2px 4px';  // Reduce padding to make the button smaller
            plusBtn.style.fontSize = '12px';    // Decrease font size to make the button smaller
            plusBtn.style.lineHeight = '1px';     // Ensure line height doesn't affect icon centering
            plusBtn.style.marginLeft = '5px';
            const plus = L.DomUtil.create('i', 'bi bi-plus-circle', plusBtn);
            plus.style.fontSize = '14px';       // Adjust icon size if needed to keep it centered

            // button to delete layer
            const deleteBtn = L.DomUtil.create('button', 'delete-btn btn btn-sm btn-outline-warning', div);
            deleteBtn.style.padding = '2px 4px';  // Reduce padding to make the button smaller
            deleteBtn.style.fontSize = '12px';    // Decrease font size to make the button smaller
            deleteBtn.style.lineHeight = '1px';     // Ensure line height doesn't affect icon centering
            deleteBtn.style.marginLeft = '5px';
            const trash = L.DomUtil.create('i', 'bi bi-trash', deleteBtn);
            trash.style.fontSize = '14px';       // Adjust icon size if needed to keep it centered            

            // input to edit a layer name
            var input = L.DomUtil.create('input','',div);
            input.value = layerName;
            input.type = 'text';
            input.style.border = "none";
            input.style.width = "max-content";
            input.focus();
            L.DomEvent.on(input, 'click', function(e) {
                L.DomEvent.preventDefault(e);
                L.DomEvent.stopPropagation(e);
            });
    
        
            function handleEnterKey(e) {
                if (e.key === 'Enter') {
                    changeLayerName(layerName, input.value);
                    
                    input.blur();
                }
                
            }
        
            L.DomEvent.on(input, 'keydown', handleEnterKey);
            
            div.appendChild(input);
            


            // add the sum of markers in the layer
            const className = `${layerName}-sum`
            const countPara = L.DomUtil.create('p', `${className} d-inline`, div);
            countPara.innerHTML = ` (${sumMarkersByLayerName(layerName)})`;
            countPara.style.color = 'grey';
            countPara.style.marginLeft = '2px';

            // Handle controls to add or remove layers to the markers
            L.DomEvent.on(plusBtn, 'click', function(e) {
                e.preventDefault(); // Prevent the default action
                L.DomEvent.stopPropagation(e);
                addToLayer(layerName);
                // update the markerCount
                countPara.innerHTML = ` (${sumMarkersByLayerName(layerName)})`;
                countPara.style.color = 'grey';
                countPara.style.marginLeft = '2px';
            });

            L.DomEvent.on(minusBtn, 'click', function(e) {
                e.preventDefault(); // Prevent the default action
                L.DomEvent.stopPropagation(e);
                removeFromLayer(layerName);
                // update the markerCount
                countPara.innerHTML = ` (${sumMarkersByLayerName(layerName)})`;
                countPara.style.color = 'grey';
                countPara.style.marginLeft = '2px';
            });

            L.DomEvent.on(deleteBtn, 'click', function(e) {
                e.preventDefault(); // Prevent the default action
                L.DomEvent.stopPropagation(e);
                deleteLayer_helper(layerName, div, deleteLayer);
                                
            });

            // Handle the layer toggle to show or hide the layer
            L.DomEvent.on(checkbox, 'change', function(e) {
                L.DomEvent.stopPropagation(e);
                L.DomEvent.preventDefault(e);
                //console.log('Layer "' + layerName + '" is visible: ' + checkbox.checked);
                toggleLayerVisibility(e.target.value);

            });

            L.DomEvent.on(selectIcon, 'click', function(e) {
                L.DomEvent.stopPropagation(e);
                L.DomEvent.preventDefault(e);
                console.log('Selecting Layer "' + layerName + '"');
                // deselect all markers
                deselectMarkers();
                // select markers in the layer
                selectMarkersByLayer(layerName);
            });

            L.DomEvent.disableClickPropagation(plusBtn);
            L.DomEvent.disableClickPropagation(minusBtn);
            L.DomEvent.disableClickPropagation(deleteBtn);

        });

        // Add the input box for a custom name and a button to create a new layer
        const inputContainer = L.DomUtil.create('div', 'input-group input-group-sm mt-2', dropdownContent);
        const customNameInput = L.DomUtil.create('input', 'form-control', inputContainer);
        customNameInput.type = 'text';
        customNameInput.placeholder = 'Custom Layer Name';


        const createLayerButton = L.DomUtil.create('button', 'btn btn-success btn-sm create-layer-button', inputContainer);
        createLayerButton.innerHTML = 'Create';

        // Return both elements to be used in event binding
        return { createLayerButton, customNameInput };
    }

    function handleCreateLayer(createLayerButton, customNameInput, dropdownContent) {
        
        // Remove any previous event listener to avoid duplication
        L.DomEvent.off(createLayerButton, 'click');
        
        // Attach the click event listener to the create button
        L.DomEvent.on(createLayerButton, 'click', function(e) {
            console.log('Create Layer Button Clicked');
            e.preventDefault(); // Prevent the default action
            L.DomEvent.stopPropagation(e);
            const layerName = customNameInput.value.trim();

            if (layerName) {
                createNewLayer(layerName);
                customNameInput.value = ''; // Clear the input after creation
                drawLayerSelections(dropdownContent); // Redraw the dropdown content
                dropdownContent.style.display = 'block';
            }
        });
        // set dropdownContent to display block
        
    }

    // Control to add a layer or remove a layer to selected markers - layer mgmt
    const LayerDropdownControl = L.Control.extend({
        onAdd: function(map) {
            const container = L.DomUtil.create('div', 'layer-dropdown-control leaflet-custom-control');
            L.DomEvent.disableClickPropagation(container);
            L.DomEvent.preventDefault(container);
            const button = L.DomUtil.create('div', 'layer-mgmt-dropdown-button leaflet-custom-button', container);
            button.innerHTML = '';  // Assuming you have an SVG background or icon set via CSS

            // Build the dropdown content container
            const dropdownContent = L.DomUtil.create('div', 'layer-dropdown-content', container);
            L.DomEvent.on(dropdownContent, 'click', L.DomEvent.stopPropagation); // Allow scrolling within the dropdown
            L.DomEvent.on(dropdownContent, 'wheel', L.DomEvent.stopPropagation); // Stop wheel event from bubbling up
    
            Object.assign(dropdownContent.style, {
                display: 'none',
                position: 'absolute',
                backgroundColor: '#fff',
                border: '1px solid #ccc',
                boxShadow: '0px 8px 16px 0px rgba(0,0,0,0.2)',
                zIndex: '9000',
                padding: '10px',
                top: '0%',  // Position below the button
                right: '115%',
                minWidth: 'max-content'
            });

            // Handle button click to show/hide dropdown
            L.DomEvent.on(button, 'click', function(e) {

                const shouldShowDropdown = dropdownContent.style.display === 'none';
                
                // Toggle the visibility of the dropdown content
                dropdownContent.style.display = shouldShowDropdown ? 'block' : 'none';

                if (shouldShowDropdown) {
                    const { createLayerButton, customNameInput } = drawLayerSelections(dropdownContent);

                    // Bind the create button event to add a new layer and refresh the dropdown content
                    handleCreateLayer(createLayerButton, customNameInput, dropdownContent);
                }
            });

            // Close the dropdown if clicked outside
            L.DomEvent.on(document, 'click', function(e) {
                if (dropdownContent.style.display === 'block' && !container.contains(e.target)) {
                    dropdownContent.style.display = 'none';
                }
            });

            return container;
        }
    });

    // Add the control to the map
    //const layerDropdownControl = new LayerDropdownControl({ position: 'topright' });
    var layerDropdownControl = new LayerDropdownControl();
    document.getElementById('custom-toolbar').appendChild(layerDropdownControl.onAdd(map));
    pluginCreationTracker['LayerMgmt_Plugin'] = true;
    //map.addControl(layerDropdownControl);
}

// Function to show the delete confirmation modal
function deleteLayer_helper(layerName, div, deleteCallback) {
    const layerNamePlaceholder = document.getElementById("layerNamePlaceholder");
    const confirmDeleteButton = document.getElementById("confirmDelete");

    // Set the layer name in the modal
    layerNamePlaceholder.textContent = layerName;

    // Show the modal
    const deleteLayerModal = new bootstrap.Modal(document.getElementById("deleteLayerModal"));
    deleteLayerModal.show();

    // Set up the delete button to call the deleteCallback when clicked
    confirmDeleteButton.onclick = function() {
        deleteCallback(layerName);
        deleteLayerModal.hide();
        // remove the div
        div.remove();
    };
}

// Example usage: 
// showDeleteLayerModal("Layer 1", function() {
//     deleteLayer("Layer 1");
// });


function changeLayerName(currentLayer, newName) {
    // Check if currentLayer exists in globalLayerAssignments
    if (!globalLayerAssignments[currentLayer]) {
        console.error('Current layer does not exist');
        return;
    }

    // Create new layer entry if it doesn't exist
    if (!globalLayerAssignments[newName]) {
        createNewLayer(newName);
    } else {
        console.error('Layer name already exists');
        return;
    }

    // Change the layer name in the globalLayerAssignments
    globalLayerAssignments[newName] = globalLayerAssignments[currentLayer];
    globalLayerAssignments[newName].name = newName;
    delete globalLayerAssignments[currentLayer];

    // For all objects in the layer, change the layer name
    ["markers", "polygons", "textMarkers"].forEach(function (obj) {
        (globalLayerAssignments[newName][obj] || []).forEach(function (marker) {
            marker.options.assignedLayers = [newName];
        });
    });
    // reorder alphabetically
    alphabetizeLayers()
}

function alphabetizeLayers() {
    globalLayerAssignments = Object.keys(globalLayerAssignments).sort().reduce(
        (obj, key) => { 
            obj[key] = globalLayerAssignments[key]; 
            return obj;
        }, 
        {}
    );
}

function isLayerVisible(layerName) {
    // check globalLayerAssignments
    if (globalLayerAssignments[layerName]) {
        //console.log(`Layer ${layerName} is visible: ${globalLayerAssignments[layerName].visible}`);
        return globalLayerAssignments[layerName].visible;
    }
}

{% comment %} function updateControlLayer(layers) {

    if (pluginCreationTracker['ControlLayers']) {
        // remove the control layers
        map.removeControl(pluginCreationTracker['ControlLayers']);
        var customLayersControl = new CustomLayersControl(null, layers, {
            collapsed: false // Disable default collapsing behavior
        }).addTo(map);
        pluginCreationTracker['ControlLayers'] = customLayersControl;
    } else {
        var customLayersControl = new CustomLayersControl(null, layers, {
            collapsed: false // Disable default collapsing behavior
        }).addTo(map);
        pluginCreationTracker['ControlLayers'] = customLayersControl;
    }
} {% endcomment %}

function insertAfter(newNode, referenceNode) {
    referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
}

// this dynamically creates the import data modal based on the the accepted excel file
function populateModal(keys) {
    const dropdownContainer = document.getElementById('dropdowns-container');
    const checkboxesContainer = document.getElementById('checkboxes-container');

    // Clear previous content
    dropdownContainer.innerHTML = '';
    checkboxesContainer.innerHTML = '';

    // Define labels for the dropdowns explicitly
    const dropdownLabels = {
        'primary-nameCol': 'Name Column',
        'primary-iconCol': 'Icon Column',
        'primary-latitudeCol': 'Latitude Column',
        'primary-longitudeCol': 'Longitude Column',
        'primary-effectsRangeCol': 'Effects Range Column',
        'primary-unitTypeCol': 'Unit Type Column',
    };

    // Create dropdowns for Primary Name, Latitude, and Longitude with specific IDs
    Object.entries(dropdownLabels).forEach(([id, labelContent]) => {
        const label = document.createElement('label');
        label.textContent = labelContent + ': ';
        label.id = id + 'Label'; // Use predefined IDs for these labels
        const select = document.createElement('select');
        select.id = id; // Use predefined IDs for these dropdowns
        select.className = 'form-select'; // Add Bootstrap class for styling

        keys.forEach(key => {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = key;
            select.appendChild(option);
            // if labelContent == 'Name Column' set the value to the key with "name" in it
            if (labelContent == 'Name Column' && key.toLowerCase().includes('name')) {
                option.selected = true;
            }
            // if labelContent == 'Latitude Column' set the value to the key with "lat" in it
            if (labelContent == 'Latitude Column' && key.toLowerCase().includes('lat')) {
                option.selected = true;
            }
            // if labelContent == 'Longitude Column' set the value to the key with "lon" in it
            if (labelContent == 'Longitude Column' && key.toLowerCase().includes('lon')) {
                option.selected = true;
            }
            if (labelContent == 'Icon Column' && key.toLowerCase().includes('icon')) {
                option.selected = true;
            }
            if (labelContent == 'Effects Range Column' && key.toLowerCase().includes('effects')) {
                option.selected = true;
            }
            if (labelContent == 'Unit Type Column' && key.toLowerCase().includes('type')) {
                option.selected = true;
            }
        });

        dropdownContainer.appendChild(label);
        dropdownContainer.appendChild(select);

    });

    // add Effects Range checkbox

    const effectsRangeLabel = document.createElement('label');
    effectsRangeLabel.id = 'effectsRangeLabel';
    effectsRangeLabel.textContent = 'Enable Effects Range';
    effectsRangeLabel.className = 'form-check-label p-2'; // Add Bootstrap class for styling

    var checkboxesRow = document.createElement('div');
    checkboxesRow.className = 'row'; // Add Bootstrap row class
    
    const effectsRangeCheckbox = document.createElement('input');
    effectsRangeCheckbox.type = 'checkbox';
    effectsRangeCheckbox.id = 'primary-effectsRange-checkbox';

    // Find the dropdown with ID 'primary-effectsRange'
    const primaryLongitude = document.getElementById('primary-longitudeCol');
    insertAfter(effectsRangeCheckbox, primaryLongitude);
    insertAfter(effectsRangeLabel, effectsRangeCheckbox);
    insertAfter(document.createElement('br'), effectsRangeLabel);
    
    
    // insert before primary-effectsRange
    dropdownContainer.insertBefore(checkboxesRow, document.getElementById('primary-effectsRangeLabel'));

    // disable primary-effectsRange and unit type
    document.getElementById('primary-effectsRangeCol').disabled = true;
    document.getElementById('primary-unitTypeCol').disabled = true;
    
    // add listener to toggle the dropdown
    effectsRangeCheckbox.addEventListener('change', function() {
        document.getElementById('primary-effectsRangeCol').disabled = !this.checked;
        document.getElementById('primary-unitTypeCol').disabled = !this.checked;
    });


    // Create checkboxes for each key, but exclude the main three keys to avoid duplication
    var checkboxesRow = document.createElement('div');
    checkboxesRow.className = 'row'; // Add Bootstrap row class

    let checkboxesCount = 0;

    keys.filter(key => !Object.values(dropdownLabels).includes(key)).forEach(key => {
        const checkboxContainer = document.createElement('div');
        checkboxContainer.className = 'col-md-auto'; // Divide row into three equal columns

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = key;
        checkbox.name = "data-fields"; // Added for grouping checkboxes
        checkbox.value = key;
        const label = document.createElement('label');
        label.htmlFor = key;
        label.textContent = key;
        label.className = 'p-2'; // Add Bootstrap class for styling
        checkbox.checked = false; // Check by default, adjust as needed

        checkboxContainer.appendChild(checkbox);
        checkboxContainer.appendChild(label);
        checkboxesRow.appendChild(checkboxContainer);

        checkboxesCount++;

        // Start a new row after every third checkbox
        if (checkboxesCount % 4 === 0) {
            checkboxesContainer.appendChild(checkboxesRow);
            checkboxesRow = document.createElement('div');
            checkboxesRow.className = 'row';
        }

        // if the checkbox is team, check it by default
        if (key.toLowerCase().includes('affiliation')) {
            checkbox.checked = true;
        }
        if (key.toLowerCase().includes('color')) {
            checkbox.checked = true;
        }

    });

    // If the last row is not complete, add it to the checkboxesContainer
    if (checkboxesRow.childNodes.length > 0) {
        checkboxesContainer.appendChild(checkboxesRow);
    }
}

function lookupUnitofMeasure(unitType) {
    let unitOfMeasure = null;
    let unitRuleDistance = null;
    jsonDataMovementArray.forEach(movementRule => {
        if (unitType === movementRule.unit_type) {
            // Find the key that includes "distance_rule"
            for (let key in movementRule) {
                if (key.includes("distance_rule")) {
                    let ruleDistance = movementRule[key]; // Use the dynamic key to access the value
                    let ruleUnitOfMeasure = movementRule.unit_of_measure;
                    unitOfMeasure = ruleUnitOfMeasure;
                    unitRuleDistance = ruleDistance;
                    break; // Exit the loop after finding the first matching key
                }
            }
        }
    });
    return {unitOfMeasure: unitOfMeasure, maxDistance: unitRuleDistance};
}

function showModal() {
    const modal = document.getElementById('dataModal');
    modal.style.display = 'block';
}

// Close Modal Logic
var closeButton = document.querySelector('.close-button');
closeButton.onclick = function() {
    var modal = document.getElementById('dataModal');
    modal.style.display = 'none';
};

// Handle form submission to import a file
document.getElementById('modalForm').onsubmit = function(e) {
    showSpinnerModal();
    e.preventDefault();
    var effectsRangeCheckboxBool = document.getElementById('primary-effectsRange-checkbox').value;
    // Retrieve the values for primary-name, primary-latitude, primary-longitude
    const primaryNameKey = document.getElementById('primary-nameCol').value;
    const primaryIconKey = document.getElementById('primary-iconCol').value;
    const primaryLatitudeKey = document.getElementById('primary-latitudeCol').value;
    const primaryLongitudeKey = document.getElementById('primary-longitudeCol').value;
    const jitterValue = parseInt(document.getElementById('customJitter').value);
    const effectsRangeKey = document.getElementById('primary-effectsRangeCol').value;
    const unitTypeKey = document.getElementById('primary-unitTypeCol').value;
    
    // Initialize an array to hold the keys selected via checkboxes
    const selectedKeys = [];
    document.querySelectorAll('#checkboxes-container input[type="checkbox"]:checked').forEach(checkbox => {
        selectedKeys.push(checkbox.value);
    });

    // Filter jsonObjects to include only the selected keys
    // Ensure this variable is accessible in this scope as discussed previously
    filteredJsonObjects = jsonObjects.map(obj => {
        const filteredObj = {};

        // Add primary attributes
        filteredObj.Icon = obj[primaryIconKey] || '';
        filteredObj.Name = obj[primaryNameKey] || '';
        if (jitterValue > 0) {
            const jitterCoords = calcJitter(jitterValue, obj[primaryLatitudeKey], obj[primaryLongitudeKey]);
            //console.log("Jitter Coords: " , jitterCoords);
            filteredObj.Latitude = jitterCoords.newLatitude;
            filteredObj.Longitude = jitterCoords.newLongitude;
        } else {
            filteredObj.Latitude = obj[primaryLatitudeKey] || '';
            filteredObj.Longitude = obj[primaryLongitudeKey] || '';
        }
        if (effectsRangeCheckboxBool = true) {
            filteredObj.EffectsRange = obj[effectsRangeKey] || '';
            filteredObj.UnitType = obj[unitTypeKey] || '';
        }

        // Include only selected keys, checking for their presence in the original object
        selectedKeys.forEach(key => {
            if (obj.hasOwnProperty(key)) { // Make sure the original object has this key
                // ignore lat long keys
                if (key !== primaryLatitudeKey && key !== primaryLongitudeKey) {
                    filteredObj[key] = obj[key];
                }
            }
        });
        return filteredObj;
    });

    //console.log(filteredJsonObjects);
    // Close the modal after processing
    document.getElementById('dataModal').style.display = 'none';


    let csrfToken = document.getElementsByName('csrfmiddlewaretoken')[0].value;
    // submit data to the server
    showSpinnerModal();
    $.ajax({
        // add csrf
        headers: { "X-CSRFToken": csrfToken },
        type: "POST",
        url: "{% url 'import_data' %}",
        data: JSON.stringify(filteredJsonObjects),
        contentType: "application/json; charset=utf-8",
        dataType: "json",
        success: function(data) {
            //console.log(data);
            if (data.status == "success") {
                newMarkers = JSON.parse(data.data);
                //console.log(newMarkers);
                initMarkers(newMarkers);
                initControlCustomToolbar();
                initLogRingsPlugin();
                initRangeRingsPlugin();
                initLRFPlugin();
                initPointofOriginPlugin();
                synchronizeLayersVisibility();
                //initLayerDisplayPlugin();
                initLayerMgmtPlugin();
                initDatatable();
                hideSpinnerModal();
                showSuccessModal("File Loaded Successfully");
                console.log("Successfully imported the file");

            }
        },
        error: function(data) {
            console.log("Error: ", data.status);
            hideSpinnerModal();
        }

    });
    
    console.log("Import function complete");
};



function initMarkers(dataArray) {
    // echo the first few rows of the data
    console.log(dataArray[0]);
    dataArray.forEach(function(item) {
        //console.log(item);
        var country = item.Country;
        // if country attribute is not present, set it to the team, if team is not present, set it to unknown

        if (!country) {
            country = item.Color;
        }
        if (!country) {
            country = "Unknown";
        }
        //console.log(country);
        var domain = item.Domain;
        //console.log(domain);
        var lat = parseFloat(item.Latitude);
        // limit to 6 decimals places
        lat = lat.toFixed(6);
        var lon = parseFloat(item.Longitude);
        // limit to 6 decimals places
        lon = lon.toFixed(6);

        if (! item.EffectsRange) {
            effectsRange = 0;
        } else {
            effectsRange = parseInt(item.EffectsRange);
        }

        if (item.UnitType) {
            var unitType = item.UnitType;
        } else {
            var unitType = "";
        }

        // Create a unique key for country-domain combination
        if (domain) {
            var layerKey = country + "-" + domain;
        } else {
            var layerKey = country;
        }


        // Check if the country layer exists, if not create it
        if (!baseLayers[country]) {
            baseLayers[country] = L.layerGroup().addTo(map);
        }

        // Check if the domain layer exists, if not create it and add to country layer
        if (!baseLayers[layerKey]) {
            baseLayers[layerKey] = L.layerGroup().addTo(baseLayers[country]);
        }

        
        
        let customIcon;
        let icon;
        let useSIDC;

        
        // check if custom icon is url
        const currentZoom = map.getZoom();
        var newSize = calculateIconSize(currentZoom);
        if (isValidUrl(item.icon)) {
            icon = item.icon;
            customIcon = L.icon({
                iconUrl: icon, // Provide the path to your custom colored icon image
                iconSize: [newSize, newSize],
                iconAnchor: [newSize / 2, newSize / 2],
                popupAnchor: [0, -45]
                
            });
        } else if (item.icon) {
            // icon = static + item.icon + '.svg';
            const static_path = "{% static 'oob-icons/' %}";
            const icon_path = static_path + item.icon + '.svg';
            customIcon = L.icon({
                iconUrl: icon_path,
                iconSize: [newSize, newSize],
                iconAnchor: [newSize / 2, newSize / 2],
                popupAnchor: [0, -45],
                className: "custom-icon"
            });
            
        
        } else {
            console.error("Icon string is empty");
            customIcon = L.icon({
                iconUrl: 'https://cdn.rawgit.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png', // Provide the path to your custom colored icon image
                iconSize: [newSize, newSize],
                iconAnchor: [newSize / 2, newSize / 2],
                popupAnchor: [0, -45]
            });
        }
        
        // trim to nly 6 characters
        unique_id = generateUniqueID();
        let drag_bool = true;

        var dataTableJSON = {
            unique_id: unique_id,
            ...item,
        }
        // remove keys that contain "icon" in them
        for (var key in dataTableJSON) {
            if (key.toLowerCase().includes("icon")) {
                delete dataTableJSON[key];
            }
        }
        
        var popupContent = buildPopupContent(item, unique_id);
        try {
            var marker = L.marker([lat, lon], {
                draggable: drag_bool,
                autoPan: true,
                latitude: lat, // Add latitude property to the marker
                longitude: lon, // Add longitude property to the marker
                start_latitude: lat,
                start_longitude: lon,
                details: popupContent,
                unique_id: unique_id,
                dataTable: dataTableJSON,
                unit_type: unitType,
                domain: domain,
                icon: customIcon,
                unit_name: item.Name,
                country: country,
                removable: false,
                attached_polygons: [],
                pmIgnore: true,
                effects_radius_nm: effectsRange,
                unitMarker: true,
                markerType: 'unit',
                rotationOrigin: 'center center',
            });

        } catch (e) {
            console.log("Error creating marker: ", e);
            console.log("Marker Data: ", item);
        }
        //console.log("Added Marker: ", marker);
        searchableLayer.addLayer(marker);
        searchableMarkers.push(marker);

        // add range rings
        processRangeRings(marker);


        marker.addTo(baseLayers[layerKey]);
        if (!marker.options.assignedLayers) {
            marker.options.assignedLayers = [];
        }
        marker.options.assignedLayers.push(layerKey);
        addToLayer(layerKey, marker);
        


        allUnitMarkers.push(marker);
        
        // add marker context 'right click' menu
        addMarkerContextMenu(marker);

        // add to L.markerClusterGroup
        //clusterMarkers.addLayer(marker);

        setupMarkerHandlers(marker, drag_bool);
        
        originalMarkers.push(marker);
        
        
        var throttleTimer;

        map.on('zoomend', function() {
            removeMarkerBubbles();
            //console.log("Zoom End");
            clearTimeout(throttleTimer);
            throttleTimer = setTimeout(function() {

                var currentZoom = map.getZoom();

                var newSize = calculateIconSize(currentZoom);
                map.eachLayer(function(layer) {
                    if (layer instanceof L.Marker && layer.options.icon) {
                        var existingSize = layer.options.icon.options.iconSize;
                        if (!existingSize || existingSize[0] !== newSize) { // Check if update is needed
                            var newIcon = L.icon({
                                iconUrl: layer.options.icon.options.iconUrl,
                                iconSize: [newSize, newSize],
                                iconAnchor: [newSize / 2, newSize / 2]
                            });
                            layer.setIcon(newIcon);
                        }
                    }
                });
                
            }, 250); // Adjust delay as needed

        });

    });
    
     // Add a control to toggle country & domain layers
    
    for (var key in baseLayers) {
        overlayMaps[key] = baseLayers[key];
    }
    //updateControlLayer(overlayMaps);
    fixAntimeridianMarkers();
}

function generateUniqueID() {
    var unique_id = md5((new Date().getTime() + Math.floor(Math.random() * 100000)).toString());
    return unique_id.substring(0, 15);
}

function buildPopupContent(item, unique_id) {
    // handle the json object or the marker object
    if (!(item instanceof L.Marker)) {
        var popupContent = "<b>" + item.Name + "</b><br>";
        let lat = item.Latitude;
        let lon = item.Longitude;
            
        popupContent += "<i> Coords: " + lat + ", " + lon + "</i><br>";
        popupContent += "<b> ID:</b> " + unique_id + "<br>";
        // add every ke, value into the popup
        for (var key in item) {
            popupContent += "<b>" + key + "</b>: " + item[key] + "<br>";
        }
    } else {
        var popupContent = "<b>" + item.options.unit_name + "</b><br>";
        let lat = item.options.latitude;
        let lon = item.options.longitude;
            
        popupContent += "<i> Coords: " + lat + ", " + lon + "</i><br>";
        popupContent += "<b> ID:</b> " + item.options.unique_id + "<br>";
        // add every ke, value into the popup
        for (var key in item.options.dataTable) {
            // if key is unique_id, skip
            if (key == "unique_id") {
                continue;
            }
            popupContent += "<b>" + key + "</b>: " + item.options.dataTable[key] + "<br>";
        }
    }
    return popupContent;
}

function addMarkerContextMenu(marker){
    marker.on('contextmenu', function(e) {
        // removing,  able to show regardless of team
        //if (e.target.options.team != playersTeam) {
        //    return;
        //}
        if (markerBubbleToggled) {
            removeMarkerBubbles();
            markerBubbleToggled = false;
            return;
        }
        // Prevent the default context menu from showing
        e.originalEvent.preventDefault();
    
        // Show bubbles or icons around the marker here
        if (selectedMarkers.length > 0) {
            selectedMarkers.forEach(function(selectedMarker) {
                showBubbles(selectedMarker);
            });
        } else {
            return;
        }
    
        // Prevent the map from being dragged if necessary
        map.dragging.disable();
        marker.dragging.disable();
        // Set the markerBubbleToggled flag to true
        markerBubbleToggled = true;
    });
}

function processRangeRings(marker) {

    if (marker.options.effects_radius_nm != null && marker.options.effects_radius_nm != 0.0  && marker.options.effects_radius_nm != "0.0"){
        //console.log("Drawing Range Rings for: ", marker.options.unit_name);
        
        // if air defense in unit_type lowercase
        if (marker.options.unit_type.toLowerCase().includes("air defense") || marker.options.unit_type.toLowerCase().includes("sam")) {
            drawAttachedRangeRings(marker);
        } else {
            drawUnitAttachedRangeRings(marker);
        }
    } else {
        //console.log("No Range Rings for: ", marker.options.unit_name);
    }


}

function convertDistance(distance, unitOfMeasure) {
    switch (unitOfMeasure) {
        case 'nm':
            return distance * 1852; // Convert nautical miles to meters
        case 'km':
            return distance * 1000; // Convert kilometers to meters
        case 'yd':
            return distance * 0.9144; // Convert yards to meters
        case 'mi':
            return distance * 1609.34; // Convert miles to meters
        case 'ft':
            return distance * 0.3048; // Convert feet to meters
        case 'm':
            return distance; // Already in meters or default case
        default:
            //console.warn('Unknown unit of measure:', unitOfMeasure);
            return NaN; // This will help identify issues with unitOfMeasure
    }
}

function getRandomUniform(min, max, size) {
    let result = [];
    for (let i = 0; i < size; i++) {
        result.push(Math.random() * (max - min) + min);
    }
    return result[0];
}

function calcJitter(jitterWeight, latitude, longitude) {
    const jitterScale = 10; // Scale factor to adjust the jitter value
    jitterWeight /= jitterScale; // Adjust the jitter value based on the scale factor
    
    //console.log("Old Latitude: ", latitude);
    //console.log("Old Longitude: ", longitude);

    let latJitter = getRandomUniform(-jitterWeight, jitterWeight, 1);
    let longJitter = getRandomUniform(-jitterWeight, jitterWeight, 1);

    //console.log("Latitude Jitter: ", latJitter);
    //console.log("Longitude Jitter: ", longJitter);

    let newLatitude = parseFloat(latitude) + latJitter;
    // limit to 6 decimal places
    newLatitude = newLatitude.toFixed(6);
    
    let newLongitude = parseFloat(longitude) + longJitter;
    // limit to 6 decimal places
    newLongitude = newLongitude.toFixed(6);

    return { newLatitude, newLongitude };
}

function showAllOriginalPaths() {
    // for all movedmarkers, show original path
    movedMarkers.forEach(function(movedMarker) {
        // find the current marker
        map.eachLayer(function(marker) {
            if (marker instanceof L.Marker && marker.options.unique_id === movedMarker.options.unique_id) {
                //console.log("Found Marker: ", marker);
                //console.log("Moving From: ", marker.options.latitude + ", " + marker.options.longitude);
                //console.log("Moving To: ", movedMarker.options.start_latitude + ", " + movedMarker.options.start_longitude);
                // Draw the original path
                drawOriginalMarkerLocation(movedMarker, marker);
            }
        });
    });
}
convertfromMeters = function(distance, unitOfMeasure) {
    switch (unitOfMeasure) {
        case 'nm':
            return distance / 1852; // Convert nautical miles to meters
        case 'km':
            return distance / 1000; // Convert kilometers to meters
        case 'yd':
            return distance / 0.9144; // Convert yards to meters
        case 'mi':
            return distance / 1609.34; // Convert miles to meters
        case 'ft':
            return distance / 0.3048; // Convert feet to meters
        case 'm':
            return distance; // Already in meters or default case
        default:
            console.warn('Unknown unit of measure:', unitOfMeasure);
            return NaN; // This will help identify issues with unitOfMeasure
    }
}

// this function was adjusted for this page
function drawOriginalMarkerLocation(movedMarker, currentMarker) {
    //console.log("Connecting Original Position to Current Position: ", movedMarker.options.unit_name, movedMarker.options.unique_id);
    var lat = movedMarker.options.start_latitude;
    var lon = movedMarker.options.start_longitude;

    positionTrackingLayer = L.layerGroup();

    const circle = L.circle([lat, lon], {
        radius: 1000,
        color: 'red',
        fillColor: 'black',
        fillOpacity: 0.5,
    })

    positionTrackingLayer.addLayer(circle);

    var latlngs = [currentMarker.getLatLng(), [lat, lon]];
    var polyline = L.polyline(latlngs, {dashArray: '5,2', weight: 1, color: 'black'});
    polyline.options.marker_type = "original_path";

    // get unit of measure from movedMarker
    // START CHANGE
    let unitType = currentMarker.options.unit_type;
    let unitOfMeasure = "mi";
    // comment out, dont need to restrict movement
    //if (currentMarker.options.unit_type) {
    //    unitOfMeasure = lookupUnitofMeasure(unitType).unitOfMeasure;
    //}
    
    //const maxDistanceDict = lookupUnitofMeasure(unitType);
    //console.log("Max Distance: ", maxDistanceDict.maxDistance);
    const actualDistance = currentMarker.getLatLng().distanceTo([lat, lon]);
    // convert distance to unit of measure
    const actualDistanceInUnit = convertfromMeters(actualDistance, unitOfMeasure).toFixed(2);
    
    // content for the popup = actual distance / max distance (unit of measure)
    const popupContent = `Name: ${currentMarker.options.unit_name}<br>Actual Distance: ${actualDistanceInUnit} ${unitOfMeasure}`;
    //console.log("Popup Content: ", popupContent);
    // END CHANGE
    // create a hover popup
    polyline.bindPopup(popupContent, {autoClose: false, closeOnClick: true});
    circle.bindPopup(popupContent, {autoClose: false, closeOnClick: true});// Add a mouseover event listener to the polyline to open the popup
    polyline.on('mouseover', function(e) {
        var layer = e.target; // Get the layer (polyline) that was hovered
        layer.openPopup(); // Open the popup attached to the polyline
    });

    // Optional: Add a mouseout event listener to close the popup when the mouse leaves the polyline
    //polyline.on('mouseout', function(e) {
    //    var layer = e.target; // Get the layer (polyline) that the mouse left
    //    layer.closePopup(); // Close the popup
    //});
    positionTrackingLayer.addLayer(polyline);
    positionTrackingLayer.options = {unique_id: movedMarker.options.unique_id};
    // Add the layer group to the map
    let layer = positionTrackingLayer.addTo(map);
    //console.log("Adding Position Tracking Layer ID: ", layer._leaflet_id);

    // Store the layer group with the unique ID for later access
    positionChangeTracker[movedMarker.options.unique_id] = layer;
}

function removeAllOriginalPaths() {
    // iterate over positionChangeTracker
    try {
        Object.keys(positionChangeTracker).forEach(function(uniqueId) {
            removePositionChangeTrackingByUniqueId(uniqueId);
        });
    } catch (error) {
        console.error("Error Removing Original Paths: ", error);
    }
        
}

function initPointofOriginPlugin() {
    if (pluginCreationTracker["PointofOrigin_Plugin"] == true) {
        console.log("Point of Origin Plugin Already Initialized");
        return;
    }
    // add the PathDraw widget
    L.Control.PathDrawChooser = L.Control.extend({
        options: {
            position: 'topright', // Default position of the control in the map
            toggle: true // 
        },
        onAdd: function(map) {
            var container = L.DomUtil.create('div', 'leaflet-custom-control');
            L.DomEvent.disableClickPropagation(container);
            // Create a button element within the container
            var link = L.DomUtil.create('a', 'toggle-paths-container leaflet-custom-button', container);
            link.href = '#';
            link.title = 'Point of Origin';
            link.innerHTML = '';  // You can use an icon or text here

            // Bind onClick event to the button
            L.DomEvent.on(link, 'click', this._onClick, this);

            // Keep track of the state
            this.showingPaths = false; // Initially not showing paths

            return container;
        },

        _onClick: function() {
            
        }
    });

    // Factory function for convenience
    L.control.pathDrawChooser = function(opts) {
        return new L.Control.PathDrawChooser(opts);
    };

    //map.addControl(L.control.pathDrawChooser({ position: 'topright' }));
    var pathDrawChooser = new L.Control.PathDrawChooser();
    document.getElementById('custom-toolbar').appendChild(pathDrawChooser.onAdd(map));
    

    // listen for click toggle-paths-container
    document.querySelector('.toggle-paths-container').addEventListener('click', function(e) {
        L.DomEvent.stopPropagation(e);
        // Toggle the showingPaths state
        this.showingPaths = !this.showingPaths;

        if (this.showingPaths) {
            showAllOriginalPaths(); // Function to show all paths
        } else {
            removeAllOriginalPaths(); // Function to remove all paths
        }
    });

// end originalPath layer control
    pluginCreationTracker["PointofOrigin_Plugin"] = true;
}


// listen for removal of a layer
map.on('pm:remove', function(e) {
    // if object is assigned to a layer, remove it from the globalLayerAssignments
    if (e.layer.options.assignedLayers) {
        console.log("Removing from assigned layers: ", e.layer.options.assignedLayers);
        e.layer.options.assignedLayers.forEach(function(layerName) {
            removeItemFromLayer(layerName, e.layer);
        });
    }
});

// add the PathDraw widget

function initLRFPlugin(){
    if (pluginCreationTracker["LRF_Plugin"] == true) {
        console.log("LRF Plugin Already Initialized");
        return;
    }
    // toggler lrf strike line visibility
    L.Control.ToggleLRF = L.Control.extend({
        
        onAdd: function(map) {
            var container = L.DomUtil.create('div', 'leaflet-control-lrf leaflet-custom-control');
            L.DomEvent.disableClickPropagation(container);
            var button = L.DomUtil.create('div', 'leaflet-custom-button', container);
            var link = L.DomUtil.create('a', 'toggle-lrf-lines', button);
            link.href = '#';
            link.title = 'Toggle LRF Strikes';
            link.innerHTML = '';  // You can use an icon or text here

            L.DomEvent.on(link, 'click', L.DomEvent.stop)
                    .on(link, 'click', toggleLRFFeatureGroupVisibility, map);

            return container;
        },
        onClick: function(e) {
            // supress normal map click behavior
            //L.DomEvent.stop(e);
        },

        onRemove: function(map) {
            // Any cleanup logic here
        }
    });

    // Add control to the mapright
    var toggleLRFControl = new L.Control.ToggleLRF();
    //toggleLRFControl.addTo(map);
    document.getElementById('custom-toolbar').appendChild(toggleLRFControl.onAdd(map));

    // create function to draw LRF strikes
    map.pm.Toolbar.createCustomControl({
        name: 'LRF Strikes',
        block: 'custom',
        title: 'Draw LRF Strikes',
        className: 'leaflet-pm-icon-polyline-lrf',
        toggle: true,

        onClick: function(e) {
            // ignore default click behavior
            L.DomEvent.stop(e);

            
            drawLRF = true;

            map.pm.enableDraw('Line', {
                snappable: true,
                color: 'red',
                templineStyle: { color: 'red', dashArray: '10, 10' },
                hintlineStyle: { color: 'red', dashArray: '10, 10' },
                pathOptions: { color: 'red', dashArray: '10, 10' },                
                finishOn: 'click',
            });
            // suppress clicks when drawing
            const container = map.getContainer();
            map.on('pm:create', function(e) {
                if (e.shape === 'Line' && drawLRF) {
                    
                    var lrfStrikeLine = e.layer;

                    var lrfLayerId = Math.random().toString(36).substr(2, 9);
                    lrfStrikeLine.options.lrfLayerId = lrfLayerId;
                    lrfStrikeLine.options.isLRF = true;
                    var coords = lrfStrikeLine.getLatLngs();
                    var lastCoord = coords.flat(1).pop();  // Flatten and get last coordinate

                    var lrfLayerGroup = L.featureGroup().addTo(map);
                    
                    lrfLayerGroups[lrfLayerId] = lrfLayerGroup;  // Store the group with an ID for reference
                    lrfLayerGroup.addLayer(lrfStrikeLine);
                    lrfLayerGroup.addLayer(L.circle(lastCoord, { lrfLayerId: lrfLayerId, radius: 2000, color: 'red', fillColor: 'red', fillOpacity: 0.5 }));
                    lrfLayerGroup.addLayer(L.circle(lastCoord, { lrfLayerId: lrfLayerId, radius: 1000, color: 'white', fillColor: 'white', fillOpacity: .3 }));
                    lrfLayerGroup.addLayer(L.circle(lastCoord, { lrfLayerId: lrfLayerId, radius: 500, color: 'red', fillColor: 'red', fillOpacity: .4 }));

                    //map.off('pm:create');  // Remove listener to avoid duplicate layers on subsequent clicks
                    drawLRF = false;
                }

                

            });

            map.on('pm:remove', function(e) {
                // Listen for removal of any layer, check if it's part of a group, and delete the whole group

                var groupId = e.layer.options.lrfLayerId;
                if (groupId && lrfLayerGroups[groupId]) {
                    lrfLayerGroups[groupId].eachLayer(function(layer) {
                        map.removeLayer(layer);  // Explicitly remove each layer
                    });
                    lrfLayerGroups[groupId].clearLayers();  // Clear all layers from the group
                    lrfLayerGroups[groupId].remove();  // Remove the group from the map
                    delete lrfLayerGroups[groupId];  // Delete the group reference
                    //console.log("Entire LRF strike group removed:", groupId);
                }
            });
        },
        toggle: false,
        actions: ['cancel']
    });
    pluginCreationTracker["LRF_Plugin"] = true;
}


// Enable suppression of click events
function suppressMapClicks() {
    // Add a transparent overlay or use existing map container to catch clicks
    var mapContainer = map.getContainer();
    L.DomEvent.on(mapContainer, 'click', L.DomEvent.stop, this);
    L.DomEvent.on(mapContainer, 'mousedown', L.DomEvent.stop, this);
}

// Disable suppression of click events
function enableMapClicks() {
    var mapContainer = map.getContainer();
    L.DomEvent.off(mapContainer, 'click', L.DomEvent.stop, this);
    L.DomEvent.off(mapContainer, 'mousedown', L.DomEvent.stop, this);
}


var lrfLayerGroups = {}; // Stores each lrfLayerGroup with a unique identifier
var drawLRF = false; // Flag to enable drawing of LRF strikes


var lrfVisState = true;  // This flag tracks the visibility state globally

function toggleLRFFeatureGroupVisibility() {
    //console.log("Toggling LRF Strike Group Visibility");
    Object.values(lrfLayerGroups).forEach(function(lrfLayerGroup) {
        lrfLayerGroup.eachLayer(function(layer) {
            //console.log("Layer: ", layer);
            toggleLRFLayerVisibility(layer);
        });
    });
    lrfVisState = !lrfVisState; // Toggle the visibility state after all layers have been processed
}

function toggleLRFLayerVisibility(layer) {
    var hasOpacity = layer.options.opacity !== undefined;
    if (lrfVisState) {
        if (hasOpacity) {
            layer.setStyle({ opacity: 0, fillOpacity: 0 });
        } else {
            map.removeLayer(layer);
        }
    } else {
        if (hasOpacity) {
            layer.setStyle({ opacity: 1, fillOpacity: 1});
        } else {
            map.addLayer(layer);
        }
    }
}




function deleteSpecificLRFStrikeGroup(lrfLayerId) {
    if (lrfLayerGroups[lrfLayerId]) {
        lrfLayerGroups[lrfLayerId].clearLayers();  // Remove all layers from the group
        lrfLayerGroups[lrfLayerId].remove();      // Remove the group from the map
        delete lrfLayerGroups[lrfLayerId];        // Delete the group reference
        console.log("LRF strike group " + lrfLayerId + " has been deleted");
    }
}



function removeCircularReference(obj) {
    const seen = new WeakSet();

    return JSON.parse(JSON.stringify(obj, function(key, value) {
        if (typeof value === "object" && value !== null) {
            if (seen.has(value)) {
                return;
            }
            seen.add(value);
        }
        return value;
    }));
}


function replacer(key, value) {
    if (key === "attached_polygons") {  // these are created on import and load
      return undefined; // Omit this key
    }
    return value; // Keep other keys
}


function saveMapDataToFile_Helper(){
    // show overwrite modal
    if (currentGlobalUuid) {
        showConfirmOverwriteModal() 
    } else {
        saveMapDataToFile(overwrite=false);
    }

}

function is_in_kmlOverlays(layer) {
    // Safely check if layer.options and layer.defaultOptions are defined
    if (layer.options.isKML) {
        return true;
    }
    if (layer?.defaultOptions?.isKML) {
        return true;
    }
    return false;
}


function saveMapDataToFile(overwrite=false, uuid="") {
    let mapData = {
        uuid: uuid,
        markers: [],
        otherLayers: []
    };
    deselectMarkers();
    map.eachLayer(function(layer) {
        // Flag to check if layer is part of kmlOverlays  // TODO: Implement this
        // if layer._leaflet_id is in kmlOverlays[i]._layers

        if (is_in_kmlOverlays(layer)) {
            return;
        }
        if (layer instanceof L.Marker) {

            // Deep copy of all layer.options keys excluding attached_polygons
                        
            // const markerOptions = JSON.parse(JSON.stringify(layer.options));
            //const markerOptions = JSON.parse(JSON.stringify(layer.options, replacer));
            const markerOptions = removeCircularReference(layer.options);
            const markerData = {
                type: 'Marker',
                latLng: layer.getLatLng(),
                options: markerOptions          // all data under options is saved
            };
            // remove options.attached_polygons
            delete markerData.options.attached_polygons;
            // Include popup content if it exists
            if (layer.getPopup()) {
                markerData.options.popupContent = layer.getPopup().getContent();
            }
            mapData.markers.push(markerData);
        } else if (layer?.pm?._shape !== undefined) {
            // Generic handling for all other layers
            //console.log(layer);
            let layerData = {
                type: layer.constructor.name, // Capture the constructor name to identify layer type
                shape: layer.pm._shape,
                options: JSON.parse(JSON.stringify(layer.options)) // Deep copy to include all options
            };
            
            // Attempt to save common properties, if applicable
            if (layer.getLatLngs) {
                layerData.latLngs = layer.getLatLngs();
            } 
            if (layer.getLatLng) {
                layerData.latLng = layer.getLatLng();
            }
            if (layer instanceof L.Circle) {
                layerData.radius = layer.getRadius();
            }

            mapData.otherLayers.push(layerData);
        }
    });
    

    // Convert mapData object to JSON string
    const jsonData = JSON.stringify(mapData, null, 2);

    // Create a Blob with JSON data
    const blob = new Blob([jsonData], { type: 'application/json' });

    // Create a link element to download the Blob
    const downloadLink = document.createElement('a');
    downloadLink.href = URL.createObjectURL(blob);
    downloadLink.download = 'map_data.great';
    
    // Trigger the download
    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);

    // Send to API endpoint for local storage


    // Get the CSRF token from the specific form by ID
    const csrfToken = document.querySelector('#saveMapData input[name="csrfmiddlewaretoken"]').value;
    //console.log("Data to Save: ", jsonData);
    var formData = new FormData();
    formData.append('file', new Blob([jsonData], { type: 'application/json' }), 'file.great');  // 'file' is the field name
    if (overwrite) {
        formData.append('previous_uuid', currentGlobalUuid);
    }
    $.ajax({
        headers: { "X-CSRFToken": csrfToken },
        type: "POST",
        url: "{% url 'save_great_file' %}",
        data: formData,
        headers: {
            'X-CSRFToken': '{{ csrf_token }}'
        },
        processData: false,  // Prevent jQuery from automatically transforming the data into a query string
        contentType: false,  // Ensure the correct content type is used (multipart/form-data)
        dataType: "json",
        success: function(data) {
            //console.log(data);
            if (data.status == "success") {
                hideSpinnerModal();
                showSuccessModal(data.uuid);
                currentGlobalUuid = data.uuid;
            }
        },
        error: function(xhr, status, error) {
        
            var errorMessage;
        
            // Include HTTP status code and status text
            errorMessage += `HTTP ${xhr.status} (${xhr.statusText}): `;
        
            if (xhr.responseText) {
                try {
                    var responseJson = JSON.parse(xhr.responseText);
                    // Use the error message from the server response if available
                    errorMessage += responseJson.message || xhr.responseText;
                } catch (e) {
                    console.error("Failed to parse JSON: ", e);
                    errorMessage += xhr.responseText;
                }
            } else {
                // If no response text, fall back to error and status
                errorMessage += error || "Unknown error";
            }
        
            showFailureModal(errorMessage);
        }
        
        
    });


}

// Function to show the modal and set up listeners
function showConfirmOverwriteModal() {

    // Set up the listener for the "Yes" button when the modal is shown
    $('#confirmOverwriteYes').off('click').on('click', function() {
// Hide the modal after confirming
        hideConfirmOverwriteModal();
        saveMapDataToFile(overwrite=true, currentGlobalUuid);
    });
    // fill in currentuid in placeholder    
    $('#currentGlobalUuid').text(currentGlobalUuid);
    
    // Show the modal
    $('#confirmOverwriteModal').modal('show');
    
}

// Function to hide the modal
function hideConfirmOverwriteModal() {
    $('#confirmOverwriteModal').modal('hide');
}

function initControlCustomToolbar() {
    if (pluginCreationTracker["CustomToolbar_Plugin"] == true) {
        console.log("Custom Toolbar Plugin Already Initialized");
        return;
    }
    // create custom toolbar container
    var CustomToolbar = L.Control.extend({
        onAdd: function(map) {
            var container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-custom-toolbar');
            container.id = 'custom-toolbar';  // Set an ID for the container
    
            return container;
        }
    });
    
    // Add the custom toolbar to the map
    var customToolbar = new CustomToolbar({ position: 'topright' }).addTo(map);
    pluginCreationTracker["CustomToolbar_Plugin"] = true;
}

// Gradient color function for heatmap
function getHeatmapColor(value) {
    if (value > 80) return '#FF0000';   // High intensity - Red
    if (value > 60) return '#FF8800';   // Medium-High - Orange
    if (value > 40) return '#FFFF00';   // Medium - Yellow
    if (value > 20) return '#80FF00';   // Low-Medium - Light Green
    return '#00FF00';                   // Low intensity - Green
}

function initMap() {
    
    
    L.control.scale().addTo(map);
    var mapLayers = L.layerGroup().addTo(map);
    L.Control.TileLayerSwitcher = L.Control.extend({
        onAdd: function(map) {
            var div = L.DomUtil.create('div', 'tile-layer-switcher');
            L.DomEvent.disableClickPropagation(div);
            // Create the dropdown container
            var dropdown = L.DomUtil.create('div', 'dropdown-container', div);
            var dropdownButton = L.DomUtil.create('button', '', dropdown);
            dropdownButton.innerHTML = '<i class="bi bi-map icons"></i>Map Tiles';
            var dropdownContent = L.DomUtil.create('div', 'dropdown-content', dropdown);
    
            // Style the dropdown (you can customize this CSS)
            dropdown.style.position = 'relative';
            dropdownButton.style.cursor = 'pointer';
            dropdownButton.style.padding = '5px 10px';
            dropdownButton.style.background = '#fff';
            dropdownButton.style.border = '1px solid #ccc';
            dropdownButton.style.borderRadius = '4px';
    
            dropdownContent.style.display = 'none'; // Initially hidden
            dropdownContent.style.position = 'absolute';
            dropdownContent.style.backgroundColor = '#fff';
            dropdownContent.style.minWidth = '160px';
            dropdownContent.style.border = '1px solid #ccc';
            dropdownContent.style.boxShadow = '0px 8px 16px 0px rgba(0,0,0,0.2)';
            dropdownContent.style.zIndex = '9000';
            dropdownContent.style.padding = '0px';

            // Scrollable window settings
            dropdownContent.style.maxHeight = '200px'; // Set max height for the dropdown
            dropdownContent.style.overflowY = 'auto'; // Enable vertical scrolling if content exceeds max height


            // Position the dropdown content to the left of the button
            dropdownContent.style.top = '0%'; // Position dropdown below the button
            dropdownContent.style.right = '100%'; // Align to the left side of the button

            

            const tileOptions = {
                streets: 'mapbox/streets-v11',
                satellite: 'mapbox/satellite-v9',
                terrain: 'mapbox/outdoors-v11'
            };
            const OPENINFRAMAP_ATTR = '<a href="https://openinframap.org/">OpenInfraMap</a>';
            const OPENWEATHER_API_KEY = "dbadfe9a94fa518bb60aba30b3cf59d2"
            const OPENAIP_API_KEY = "36fa058ceb25866e7b5ea54dae1279f0";
            const MAPBOX_TOKEN = "pk.eyJ1IjoieW91cmVnb2luZ3RvZG9ncmVhdCIsImEiOiJjbHp4Z3h6YXMwcjJhMmtweHFkMjNhNGVvIn0.frJLiqLnISInCNjgV16kcw"
            // Define your layers

            // Define the WMS service URL (without the GetCapabilities parameters)
            var wmsUrl = 'https://mapservices.weather.noaa.gov/static/services/nws_reference_maps/nws_reference_map/MapServer/WMSServer';

            // Define the WMS layer name (replace 'ReferenceMap' with the actual layer name)
            var wmsLayerName = 'ReferenceMap';

            var layers = {
                'Esri.WorldStreetMap': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 5, 
                    detectRetina: true,
                    attribution: 'Tiles &copy; Esri',
                    
                    
                }),
                'Labels': L.tileLayer('https://tiles.stadiamaps.com/tiles/stamen_toner_labels/{z}/{x}/{y}{r}.{ext}?api_key=93e6c283-e771-4e7b-b36a-3f148226bb59', {
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 5, 
                    ext: 'png', 
                    detectRetina: true,
                    attribution: 'Tiles &copy; Stadia Maps',
                    
                }),
                'Stadia_AlidadeSmooth': L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_smooth/{z}/{x}/{y}{r}.png', {
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 5, 
                    detectRetina: true,
                    attribution: 'Tiles &copy; Stadia Maps',
                    
                }),
                'Stadia_AlidadeSatellite': L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_smooth/{z}/{x}/{y}{r}.png', {
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 5, 
                    detectRetina: true,
                    attribution: 'Tiles &copy; Stadia Maps',
                    
                }),
                'OpenStreetMap': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 5,
                    detectRetina: true,
                    attribution: 'Tiles &copy; OpenStreetMap',
                    

                }),
                'Topographic': L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 5, 
                    detectRetina: true,
                    attribution: 'Tiles &copy; OpenTopoMap',
                    
                }),
                'Satellite': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 5, 
                    detectRetina: true,
                    attribution: 'Tiles &copy; Esri',
                    
                }),
                'TopPlusOpen.Color': L.tileLayer('http://sgx.geodatenzentrum.de/wmts_topplus_open/tile/1.0.0/web/default/WEBMERCATOR/{z}/{y}/{x}.png', {
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 5,
                    
                    detectRetina: true,
                    attribution: 'Tiles &copy; GeoBasis-DE / BKG 2021',
                }),
                'Google Terrain': L.tileLayer('http://mt0.google.com/vt/lyrs=m&hl=en&x={x}&y={y}&z={z}&s=Ga', {
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 5, 
                    detectRetina: true,
                    
                    attribution: 'Tiles &copy; Google',
                }),
                'Google Hybrid': L.tileLayer('http://mt0.google.com/vt/lyrs=y&hl=en&x={x}&y={y}&z={z}&s=Ga', {
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 5, 
                    detectRetina: true,
                    
                    attribution: 'Tiles &copy; Google',
                }),
                'Google Satellite': L.tileLayer('http://mt0.google.com/vt/lyrs=s&hl=en&x={x}&y={y}&z={z}&s=Ga', {
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 5, 
                    detectRetina: true,
                    
                    attribution: 'Tiles &copy; Google',
                }),
                'Google Traffic': L.layerGroup([
                    L.tileLayer('http://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                        useCache: true, 
                        crossOrigin: true, 
                        edgeBufferTiles: 5, 
                        detectRetina: true,
                        
                    }), // Satellite base
                    L.tileLayer('http://mt1.google.com/vt/lyrs=h&x={x}&y={y}&z={z}', {
                        useCache: true, 
                        crossOrigin: true, 
                        edgeBufferTiles: 5, 
                        detectRetina: true,
                        
                    }), // Hybrid overlay (roads/labels)
                    L.tileLayer('http://mt0.google.com/vt/lyrs=h@159000000,traffic|seconds_into_week:-1&hl=en&x={x}&y={y}&z={z}&s=Ga', {
                        useCache: true, 
                        crossOrigin: true, 
                        edgeBufferTiles: 5, 
                        detectRetina: true,
                        
                        attribution: 'Tiles &copy; Google'
                    }) // Traffic overlay
                ]),
                'Esri World Topo Map': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 5, 
                    detectRetina: true,
                    
                    attribution: 'Tiles &copy; Esri'
                }),
                'Esri World Physical Map': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Physical_Map/MapServer/tile/{z}/{y}/{x}', {
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 5, 
                    detectRetina: true,
                    
                    attribution: 'Tiles &copy; Esri'
                }),
                'Esri World Shaded Relief Map': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}', {
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 5, 
                    detectRetina: true,
                    
                    attribution: 'Tiles &copy; Esri'
                }),
                'Esri World Imagery': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}@2x', {
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 5, 
                    detectRetina: true,
                    
                    attribution: 'Tiles &copy; Esri'
                }),
                'Esri World Navigation Charts': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Specialty/World_Navigation_Charts/MapServer/tile/{z}/{y}/{x}', {
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 5, 
                    detectRetina: true,
                    
                    attribution: 'Tiles &copy; Esri'
                }),
                'Esri World Ocean Base': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Ocean/World_Ocean_Base/MapServer/tile/{z}/{y}/{x}', {
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 5, 
                    detectRetina: true,
                    
                    attribution: 'Tiles &copy; Esri'
                }),
                'USGS_USImageryTopo': L.tileLayer('https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryTopo/MapServer/tile/{z}/{y}/{x}', {
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 10, 
                    detectRetina: true,
                    
                    attribution: 'Tiles &copy; USGS'
                }),
                'Open Railway Map': L.tileLayer('https://{s}.tiles.openrailwaymap.org/standard/{z}/{x}/{y}.png', {
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 10, 
                    detectRetina: true,
                    
                    attribution: 'Tiles &copy; OpenRailwayMap'
                }),
                'Open Railway Group': L.layerGroup([
                    L.tileLayer('http://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                        useCache: true, 
                        crossOrigin: true, 
                        edgeBufferTiles: 10, 
                        detectRetina: true,
                        
                    }), // Satellite base
                    L.tileLayer('https://{s}.tiles.openrailwaymap.org/standard/{z}/{x}/{y}.png', {
                        useCache: true, 
                        crossOrigin: true, 
                        edgeBufferTiles: 10, 
                        detectRetina: true,
                        
                    }),
                ]),
                'Open Sea Map': L.tileLayer('https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="http://www.openseamap.org/">OpenSeaMap</a> contributors',
                    maxZoom: 18,
                    tileSize: 256,
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 10, 
                    detectRetina: true,
                    

                }),
                'GEBCO Latest': L.tileLayer.wms('https://wms.gebco.net/2024/mapserv?', {
                    service: 'WMS',
                    request: 'GetMap',
                    layers: 'GEBCO_2024',
                    format: 'image/png',
                    transparent: true,
                    
                    attribution: '&copy; GEBCO', 
                    detectRetina: true,
                    useCache: true,
                    crossOrigin: true,
                    edgeBufferTiles: 10

                  }),
                'NOAA': L.esri.dynamicMapLayer({
                    url: 'https://gis.charttools.noaa.gov/arcgis/rest/services/MCS/ENCOnline/MapServer',
                    opacity: 0.7,
                    attribution: '&copy; NOAA ENCOnline',
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 10,
                    detectRetina: true,
                    
                }),
                'Aeronautical Informtion (AIP)': L.tileLayer(`https://{s}.api.tiles.openaip.net/api/data/openaip/{z}/{x}/{y}.png?apiKey=${OPENAIP_API_KEY}`, {
                    attribution: '&copy; OpenAIP',
                    maxZoom: 10,
                    minZoom: 4,
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 10, 
                    detectRetina: true,
                    
                }),
                'Mapbox Outdoors': L.tileLayer(`https://api.mapbox.com/styles/v1/mapbox/outdoors-v12/tiles/{z}/{x}/{y}?access_token=${MAPBOX_TOKEN}`, {
                    detectRetina: true,      // Sharp display on high-DPI screens
                    attribution: 'Map data © Mapbox',
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 10,
                    
                }),
                'Mapbox Satellite': L.tileLayer(`https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/{z}/{x}/{y}?access_token=${MAPBOX_TOKEN}`, {
                    detectRetina: true,      // Sharp display on high-DPI screens
                    attribution: 'Map data © Mapbox',
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 10,
                    
                }),
                'Mapbox Sat Streets': L.tileLayer(`https://api.mapbox.com/styles/v1/mapbox/satellite-streets-v12/tiles/{z}/{x}/{y}?access_token=${MAPBOX_TOKEN}`, {
                    detectRetina: true,      // Sharp display on high-DPI screens
                    attribution: 'Map data © Mapbox',
                    useCache: true, 
                    crossOrigin: true, 
                    edgeBufferTiles: 10,
                    
                }),
                'Mapbox Streets': L.tileLayer(`https://api.mapbox.com/styles/v1/mapbox/streets-v12/tiles/{z}/{x}/{y}?access_token=${MAPBOX_TOKEN}`, { 
                    detectRetina: true,
                    attribution: 'Map data © Mapbox',
                    useCache: true,
                    crossOrigin: true,
                    edgeBufferTiles: 10,
                                   
                
                }),

                'OpenInfraMap Petroleum': L.vectorGrid.protobuf('https://openinframap.org/map/petroleum/{z}/{x}/{y}.pbf', {
                    maxZoom: 17,
                    attribution: OPENINFRAMAP_ATTR,
                    vectorTileLayerStyles: {
                        default: { weight: 1, color: '#993300', fill: true, fillColor: '#CC6633', fillOpacity: 0.6 }
                    }
                }),
                'OpenWeather_Temp': L.tileLayer('https://tile.openweathermap.org/map/temp_new/{z}/{x}/{y}.png?appid=' + OPENWEATHER_API_KEY, {
                    attribution: '&copy; <a href="https://openweathermap.org/">OpenWeather</a>',
                    maxZoom: 19,
                    opacity: 1,
                    fill_bound: true,
                    name: 'Temperature',
                    
                }),

                'OpenWeather_Precip': L.tileLayer('https://tile.openweathermap.org/map/precipitation_new/{z}/{x}/{y}.png?appid=' + OPENWEATHER_API_KEY, {
                    attribution: '&copy; <a href="https://openweathermap.org/">OpenWeather</a>',
                    maxZoom: 19,
                    opacity: 1,
                    fill_bound: true,
                    name: 'Precipitation',
                    
                }),

                'OpenWeather_Clouds': L.tileLayer('https://tile.openweathermap.org/map/clouds_new/{z}/{x}/{y}.png?appid=' + OPENWEATHER_API_KEY, {
                    attribution: '&copy; <a href="https://openweathermap.org/">OpenWeather</a>',
                    maxZoom: 19,
                    opacity: 1,
                    fill_bound: true,
                    name: 'Clouds',
                    
                }),
                'OpenWeather_Snow': L.tileLayer('https://tile.openweathermap.org/map/snow_new/{z}/{x}/{y}.png?appid=' + OPENWEATHER_API_KEY, {
                    attribution: '&copy; <a href="https://openweathermap.org/">OpenWeather</a>',
                    maxZoom: 19,
                    opacity: 0.5,
                    name: 'Snow',
                    
                }),

            };
            

            // Create the legend control, but don't add it to the map yet
            var gebcoLegend = L.control({ position: 'bottomright' });

            gebcoLegend.onAdd = function(map) {
                // Create a div element for the legend
                var div = L.DomUtil.create('div', 'info legend');

                
                // Add the legend image
                div.innerHTML = '<img src="https://www.gebco.net/data_and_products/gebco_web_services/web_map_service/images/gebco_depth_colour_key_vertical.jpg" alt="Depth Legend" style="height: 10rem">';
                
                // Get the image element
                var img = div.querySelector('img');

                // Attach mouseover and mouseout events
                L.DomEvent.on(img, 'mouseover', function() {
                    this.style.height = '20rem'; // Enlarge the image on hover
                });

                L.DomEvent.on(img, 'mouseout', function() {
                    this.style.height = '10rem'; // Restore the original size when not hovering
                });

                return div;
            };

            

            // Create checkboxes for each layer inside the dropdown
            Object.keys(layers).forEach(function(name) {
                //console.log("Layer Name: ", name);
                var label = L.DomUtil.create('label', '', dropdownContent);
                label.style.minWidth = '12rem';
                label.style.padding = "2px 5px";
                label.style.margin = "2px";
                var input = L.DomUtil.create('input', '', label);
                input.type = 'checkbox';
                input.value = name;
                input.defaultChecked = false;
                label.appendChild(document.createTextNode(' ' + name));
                if (name == "Esri.WorldStreetMap") {
                    input.checked = true;
                }
    
                // Handle the layer toggle
                L.DomEvent.on(input, 'change', function(e) {
                    var layer = layers[e.target.value];
                    if (e.target.checked) {
                        //map.addLayer(layer);
                        // add layer to layergroup
                        mapLayers.addLayer(layer);

                        // Add the legend when the GEBCO Latest layer is selected
                        if (name === 'GEBCO Latest') {
                            gebcoLegend.addTo(map);
                        }
                        
                    } else {
                        //map.removeLayer(layer);
                        // remove layer from layergroup
                        mapLayers.removeLayer(layer);

                        if (name === 'GEBCO Latest') {
                            map.removeControl(gebcoLegend);
                        }
                    }
                });
                


            });
    
            // Toggle the dropdown visibility on button click
            L.DomEvent.on(dropdownButton, 'click', function() {
                dropdownContent.style.display = dropdownContent.style.display === 'block' ? 'none' : 'block';
            });
            
            // disable double click on map
            L.DomEvent.on(dropdownContent, 'dblclick', function(e) {
                L.DomEvent.stopPropagation(e);
            });

            // Handle the wheel event on the dropdown
            L.DomEvent.on(dropdownContent, 'wheel', function(e) {
                // Allow scrolling within the dropdown
                var scrollHeight = dropdownContent.scrollHeight;
                var scrollTop = dropdownContent.scrollTop;
                var clientHeight = dropdownContent.clientHeight;

                // Check if at the top or bottom of the scrollable area
                if (
                    (scrollTop === 0 && e.deltaY < 0) || // At the top and scrolling up
                    (scrollTop + clientHeight >= scrollHeight && e.deltaY > 0) // At the bottom and scrolling down
                ) {
                    // Stop the event propagation to prevent map zoom
                    L.DomEvent.stopPropagation(e);
                    e.preventDefault();
                } else {
                    // Let the scroll happen within the dropdown
                    L.DomEvent.stopPropagation(e); // Still stop propagation to prevent affecting the map
                }
            });

            return div;
        }
    });

    L.control.tileLayerSwitcher = function(opts) {
        return new L.Control.TileLayerSwitcher(opts);
    }

    map.addControl(L.control.tileLayerSwitcher({position: 'topright'}));

    // leaflet geoman
    var geomanGroup = L.featureGroup().addTo(map);

    map.pm.addControls({
        position: 'topleft',
        drawCircle: true,
        drawCircleMarker: true,
        drawMarker: false,
        drawPolygon: true,
        drawPolyline: false,
        drawRectangle: true,
        editMode: true,
        dragMode: true,
        cutPolygon: true,
        removalMode: true,
        rotateMode: true,
        scaleMode: true,
    });
    map.pm.Toolbar.copyDrawControl("Line", {
        name: "CustomLine",
        snappable: true,
        templineStyle: { color: "#3388ff", dashArray: '5, 5' },
        hintlineStyle: { color: "#3388ff", dashArray: '5, 5' },
        pathOptions: { color: "#3388ff", dashArray: '5, 5' },
        finishOn: 'dblclick'
    });
    

    // Add event listener to the featureGroup layer for when a new shape is created
    map.on('pm:create', function(e) {
        var layer = e.layer;
        layer.options.shape = e.shape;
        layer.options.unique_id = generateUniqueID();

        // special handling for text markers
        if (layer.options.textMarker) {
            layer.dragging.enable();

        }


        var clickTimeout;
        
        if (!layer.options.textMarker) {
            // Attach dblclick event to the new shape
            layer.on('dblclick', function(e) {
                console.log('Double Clicked on Layer:', layer);
                L.DomEvent.stopPropagation(e);
        
                // Clear the click timeout to prevent the single click action
                if (clickTimeout) {
                    clearTimeout(clickTimeout);
                    clickTimeout = null;
                }
        
                var newColor = document.getElementById('color-picker').value;
                selectedPolygon = layer;
                if (!layer.options.textMarker){  
                    selectedPolygon.setStyle({ fillColor: newColor, color: newColor });
                }
                
                
            });
        
            // Attach click event to the new shape
            layer.on('click', function(e) {
                // Clear any existing timeout to avoid double handling
                if (clickTimeout) {
                    clearTimeout(clickTimeout);
                }
        
                // Set a timeout for the single click action
                clickTimeout = setTimeout(function() {
                    // prevent propagation
                    L.DomEvent.stopPropagation(e);
                    if (!layer.options.textMarker) {         // not text marker
                        toggleShapeSelection(e);
                    }
                }, 200); // Adjust the delay time as needed
            });
        } else {
            layer.on('click', function(e) {
                console.log("Clicked a Text Marker");
                const textMarker = e.target;
                if (selectedTextMarkers.includes(textMarker)) {
                    // Deselect the text marker
                    deselectItem(textMarker);
                } else {
                    selectItem(textMarker);
                }
            });
            
        }
    });
    

    // Define custom ColorPickerControl
    var ColorPickerControl = L.Control.extend({
        onAdd: function(map) {
            // Create container element for color picker
            var container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
            L.DomEvent.disableClickPropagation(container);
            // Create color picker input element
            var colorPicker = document.createElement('input');
            colorPicker.type = 'color';
            colorPicker.id = 'color-picker'; // Set an ID for styling or event handling
            colorPicker.title = 'Choose color';
            
            // Append color picker to container
            container.appendChild(colorPicker);

            return container;
        },

        onRemove: function(map) {
            // Nothing to do here
        }
    });

    // Add custom control to the map
    var colorPickerControl = new ColorPickerControl({ position: 'topleft' }); // Adjust position as needed
    colorPickerControl.addTo(map);

    

    // Initialize the Lasso tool
    var lassoControl = new L.Control.Lasso({position: 'topright'});
    lassoControl.addTo(map);

    map.on('lasso.finished', function(event) {
        deselectMarkers(); // Optionally clear existing selection first
        console.log('Selected Layers:', event.layers);
        event.layers.forEach(function(layer) {
            if (layer.options.hidden !== true && layer.type !== "context-menu") {
                if (layer instanceof L.Marker && !layer.options.textMarker) {
                    selectedMarkers.push(layer);
                    // Update the visual style of the marker to indicate it's selected
                    updateMarkerStyle(true, layer); // Assuming this function changes the marker's icon or style
                    const uniqueIdColumnIndex = 0; // The column index for unique_id
                    selectedMarkersByUniqueID = selectedMarkers.map(marker => marker.options.unique_id);
                    if (selectedMarkersByUniqueID.length > 0) {
                        filterDataTableByUniqueIds(selectedMarkersByUniqueID, uniqueIdColumnIndex);
                    }
                }
                // handle other layers
                else if (layer.pm._layer && !layer.options.textMarker) {
                    selectedShapes.push(layer);
                    // Update the visual style of the polygon to indicate it's selected
                    updateShapeStyle(true, layer); // Assuming this function changes the polygon's style
                } else if (layer.options.textMarker) {
                    selectedTextMarkers.push(layer);
                    // Update the visual style of the text marker to indicate it's selected
                    updateMarkerStyle(true, layer); // the function does not change, separating the condition for clarity
                }
            }
        });
        
    });

    
}

let currentMarker = null; // Track the currently selected SVG marker



function changeUnitRingsSelection(newValue) {
    var select = document.getElementById('unitRangeRingsSwitcherSelect');
    if (!select) {
        console.error('Range Rings Switcher select element not found');
        return;
    }
    
    // Update the select value
    select.value = newValue;
    
    // Manually trigger the 'change' event on the select element
    var event = new Event('change', { bubbles: true });
    select.dispatchEvent(event);
}

var rangeRingsLayerGroupTracker = {};
var logRingsLayerGroupTracker = {};
var rangeRingsLayerGroup = L.layerGroup();

function initLogRingsPlugin() {
    if (pluginCreationTracker["LogRings_Plugin"]) {
        console.log("Log Rings Plugin already initialized");
        return;
    }
    L.Control.LogCheckboxDropdown = L.Control.extend({
        onAdd: function(map) {
            var container = L.DomUtil.create('div', 'log-rings-switcher leaflet-custom-control');
            
            container.style.position = 'relative'; // Ensure the container can hold absolutely positioned elements

            var dropdownContainer = L.DomUtil.create('div', 'dropdown leaflet-custom-button', container);
            //L.DomEvent.disableClickPropagation(dropdownContainer);
            // Keep position style empty to allow for natural document flow within the container

            var dropdownButton = L.DomUtil.create('a', 'dropdown-button toggle-log-ring-layers', dropdownContainer);
            dropdownButton.href = '#';
            // Set button content (use an SVG icon or text)
            dropdownButton.innerHTML = ''; // Placeholder for button content

            var dropdownContent = L.DomUtil.create('div', 'dropdown-content', dropdownContainer);
            L.DomEvent.on(dropdownContent, 'click', L.DomEvent.stopPropagation); // Allow scrolling within the dropdown
            L.DomEvent.on(dropdownContent, 'wheel', L.DomEvent.stopPropagation); // Stop wheel event from bubbling up
            dropdownContent.style.display = 'none';
            dropdownContent.style.position = 'absolute';
            dropdownContent.style.zIndex = '9999'; // Ensure it appears above other controls
            dropdownContent.style.right = "1px";
            dropdownContent.style.top = "1px";

            // Position the dropdown content to the left of the button
            dropdownContent.style.top = '0%'; // Position dropdown below the button
            dropdownContent.style.right = '115%'; // Align to the left side of the button

            const teamNames = Object.keys(logRingsLayerGroupTracker);

            teamNames.forEach(teamName => {
                var label = document.createElement('label');
                label.style.display = 'block';
                label.style.padding = '3px';
                label.style.margin = '0px';
                label.innerText = teamName;
                label.style.zIndex = '9999';
                

                var checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = teamName;
                checkbox.style.marginRight = '5px';

                label.insertBefore(checkbox, label.firstChild);

                dropdownContent.appendChild(label);

                checkbox.addEventListener('change', (e) => {
                    toggleLogRingLayerVisibility(e.target.value);
                });
            });
            // Toggle dropdown visibility on button click
            L.DomEvent.on(dropdownButton, 'click', function(e) {
                console.log("Clicked on Log Rings Dropdown Button");
                L.DomEvent.stopPropagation(e);
                // Toggle visibility of the dropdown content
                if (dropdownContent.style.display === 'block') {
                    dropdownContent.style.display = 'none';
                } else {
                    dropdownContent.style.display = 'block';
                }
            });

            // Ensure clicking inside dropdown doesn't close it
            L.DomEvent.on(dropdownContent, 'click', function(e) {
                L.DomEvent.stopPropagation(e);
            });

            // Hide dropdown when clicking outside of it
            L.DomEvent.on(document, 'click', function() {
                dropdownContent.style.display = 'none';
            });

            // disable double click on map
            L.DomEvent.on(dropdownContent, 'dblclick', function(e) {
                L.DomEvent.stopPropagation(e);
            });

            return container;
        }
    });

    //map.addControl(new L.Control.LogCheckboxDropdown({position: 'topright'}));
    var logRingsControl = new L.Control.LogCheckboxDropdown();
    document.getElementById('custom-toolbar').appendChild(logRingsControl.onAdd(map));
    pluginCreationTracker["LogRings_Plugin"] = true;
}


function initTopoControls() {
    if (pluginCreationTracker["TopoControls_Plugin"]) {
        console.log("Topo Controls Plugin already initialized");
        return;
    }
    const topoHoverControl = L.Control.extend({
        onAdd: function(map) {
            const div = L.DomUtil.create('div', 'leaflet-control-topo-hover');
            div.innerHTML = '<button id="enable-hover">Enable Topographic Hover</button>';
            div.firstChild.onclick = function() {
                map.fire('toggleTopoHover');
            };
            return div;
        }
    });

    L.control.topographicHover = function(opts) {
        return new topoHoverControl(opts);
    };

    let enabled = false;

    map.on('toggleTopoHover', function() {
        enabled = !enabled;
        document.getElementById('enable-hover').innerText = enabled ? 'Disable Topographic Hover' : 'Enable Topographic Hover';
        if (enabled) {
            map.on('click', onMouseClick);

        } else {
            map.off('click', onMouseClick);
        }
    });

    function onMouseClick(e) {
        const lat = e.latlng.lat;
        const lng = e.latlng.lng;
        fetchTerrainData(lat, lng).then(data => {
            
            console.log(data);
        });
    }

    async function fetchTerrainData(lat, lng) {
        const elevationResponse = await fetch(`https://api.opentopodata.org/v1/test-dataset?locations=${lat},${lng}`,{mode: 'cors'});
        const elevationData = await elevationResponse.json();
        const elevation = elevationData.results[0].elevation;

        const terrainResponse = await fetch(`https://overpass-api.de/api/interpreter?data=[out:json];way(around:50,${lat},${lng})[natural];out;`, {mode: 'cors'});
        const terrainData = await terrainResponse.json();

        let terrain = 'Unknown';
        if (terrainData.elements.length > 0) {
            const terrainType = terrainData.elements[0].tags.natural;
            switch(terrainType) {
                case 'water':
                    terrain = 'Body of Water';
                    break;
                case 'wetland':
                    terrain = 'Wetland';
                    break;
                case 'desert':
                    terrain = 'Desert';
                    break;
                case 'marsh':
                    terrain = 'Marsh';
                    break;
                case 'scrub':
                    terrain = 'Scrubland';
                    break;
                // Add more cases as needed
                default:
                    terrain = 'Other';
            }
        }

        return {
            elevation: elevation,
            terrain: terrain
        };
    }

    L.control.topographicHover({ position: 'topright' }).addTo(map);
    pluginCreationTracker["TopoControls_Plugin"] = true;
}


function removePositionChangeTrackingByUniqueId(uniqueId) {
    //console.log("Removing Position Change Tracking Layer for:", uniqueId);

    let layer = positionChangeTracker[uniqueId];
    
    if (layer) {
        //console.log("Removing Position Tracking Layer ID: ", layer);
        map.removeLayer(layer); // Remove from the map
        delete positionChangeTracker[uniqueId];

        // search all layers for layergroup type with unique_id
        map.eachLayer(function(layer) {
            if (layer instanceof L.LayerGroup && layer.options.unique_id === uniqueId) {
                map.removeLayer(layer);
            }
        });
        // this should not be the prefered method, but the only way to remove the layer for sure


    } else {
        //console.log("No tracking layer found for uniqueId:", uniqueId);
    }
}

function initRangeRingsPlugin() {
    if (pluginCreationTracker["RangeRings_Plugin"]) {
        console.log("Range Rings Plugin already initialized");
        return;
    }
    L.Control.RangeCheckboxDropdown = L.Control.extend({
        onAdd: function(map) {
            var container = L.DomUtil.create('div', 'range-rings-switcher leaflet-custom-control');
            L.DomEvent.disableClickPropagation(container);
            container.style.position = 'relative'; // Ensure the container can hold absolutely positioned elements

            var dropdownContainer = L.DomUtil.create('div', 'dropdown leaflet-custom-button', container);
            // Keep position style empty to allow for natural document flow within the container

            var dropdownButton = L.DomUtil.create('a', 'dropdown-button toggle-range-ring-layers leaflet-custom-button', dropdownContainer);
            dropdownButton.href = '#';
            // Set button content (use an SVG icon or text)
            dropdownButton.innerHTML = ''; // Placeholder for button content

            var dropdownContent = L.DomUtil.create('div', 'dropdown-content', dropdownContainer);
            L.DomEvent.on(dropdownContent, 'click', L.DomEvent.stopPropagation); // Allow scrolling within the dropdown
            L.DomEvent.on(dropdownContent, 'wheel', L.DomEvent.stopPropagation); // Stop wheel event from bubbling up
            dropdownContent.style.display = 'none';
            dropdownContent.style.position = 'absolute';
            dropdownContent.style.zIndex = '9999'; // Ensure it appears above other controls
            dropdownContent.style.right = "1px";
            dropdownContent.style.top = "1px";

            // Position the dropdown content to the left of the button
            dropdownContent.style.top = '0%'; // Position dropdown below the button
            dropdownContent.style.right = '115%'; // Align to the left side of the button

            const teamNames = Object.keys(rangeRingsLayerGroupTracker);

            teamNames.forEach(teamName => {
                var label = document.createElement('label');
                label.style.display = 'block';
                label.style.padding = '3px';
                label.style.margin = '0px';
                label.innerText = teamName;
                label.style.zIndex = '9999';
                

                var checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = teamName;
                checkbox.style.marginRight = '5px';

                label.insertBefore(checkbox, label.firstChild);

                dropdownContent.appendChild(label);

                checkbox.addEventListener('change', (e) => {
                    toggleRangeRingLayerVisibility(e.target.value);
                });
            });

            // Toggle dropdown visibility on button click
            L.DomEvent.on(dropdownButton, 'click', function(e) {
                L.DomEvent.stopPropagation(e); // Stops the event from bubbling up to the map
                L.DomEvent.preventDefault(e);  // Prevents the default behavior of the event
                
                // Toggle visibility of the dropdown content
                dropdownContent.style.display = dropdownContent.style.display === 'block' ? 'none' : 'block';
            });

            // Ensure clicking inside dropdown doesn't close it
            L.DomEvent.on(dropdownContent, 'click', function(e) {
                L.DomEvent.stopPropagation(e);
                L.DomEvent.stopPropagation(e);
            });

            // disable double click on map
            L.DomEvent.on(dropdownContent, 'dblclick', function(e) {
                L.DomEvent.stopPropagation(e);
            });

            // Hide dropdown when clicking outside of it
            L.DomEvent.on(document, 'click', function() {
                dropdownContent.style.display = 'none';
            });

            return container;
        }
    });

    //map.addControl(new L.Control.RangeCheckboxDropdown({position: 'topright'}));
    var rangeRingsControl = new L.Control.RangeCheckboxDropdown();
    document.getElementById('custom-toolbar').appendChild(rangeRingsControl.onAdd(map));
    pluginCreationTracker["RangeRings_Plugin"] = true;
}

L.Control.RulerWithUnitSelector = L.Control.extend({
    options: {
        position: 'bottomright' // Adjust position to bottom left
    },
    onAdd: function(map) {
        var container = L.DomUtil.create('div', 'leaflet-control-ruler-unit-selector leaflet-bar');
        var select = L.DomUtil.create('select', 'leaflet-ruler-unit-selector', container);
        select.innerHTML = `
            <option value="km">Kilometers</option>
            <option value="m">Meters</option>
            <option value="miles">Miles</option>
            <option value="nm">Nautical Miles</option>
        `;
        // add id
        select.id = 'leaflet-ruler-unit-selector';
        // Handle unit changes
        L.DomEvent.on(select, 'click', (e) => {
            e.preventDefault();
            L.DomEvent.stopPropagation(e);
            // Check if the ruler is active before allowing the unit to be changed
            if (this._rulerControl && !this._rulerControl.isActive()) {
                this.updateRuler(e.target.value);
            } else {
                // Optionally, you could reset the select to its previous value or show a message
                alert("You cannot change the unit while drawing. Please finish your measurement first.");
                // Reset the select to its previous value
                select.value = this._currentUnit;
            }
        });
        

        // Keep a reference to the map to use in other methods
        this._map = map;

        // Initially set up the ruler with the default unit (km)
        this.updateRuler('km');

        return container;
    },
    

    updateRuler: function(selectedUnit) {
        // Define conversion factors for each unit
        const unitsConfig = {
            km: {display: 'km', decimal: 2, factor: 1, label: 'Distance:'},
            m: {display: 'm', decimal: 0, factor: 1000, label: 'Distance:'},
            miles: {display: 'mi', decimal: 2, factor: 0.621371, label: 'Distance:'},
            nm: {display: 'nm', decimal: 2, factor: 0.539957, label: 'Distance:'}
        };

        // Remove existing ruler control if it exists
        if (this._rulerControl) {
            this._map.removeControl(this._rulerControl);
        }

        // Create a new ruler control with the selected unit settings
        this._rulerControl = L.control.ruler({
            position: 'bottomright',
            lengthUnit: unitsConfig[selectedUnit],
        
        }).addTo(this._map);
        
    }
});


L.control.rulerWithUnitSelector = function(options) {
    return new L.Control.RulerWithUnitSelector(options);
};

// Assuming the map variable is already defined
L.control.rulerWithUnitSelector().addTo(map);

// trigger a change on leaflet-ruler-unit-selector select
document.querySelector('.leaflet-ruler-unit-selector').dispatchEvent(new Event('change'));

var bubbleLayerTracker = {};
var markerBubbleToggled = false;

function bubbleShowPath(marker) {
    //console.log('Drawing Path');
    // find movedMarker if exists by unique_id
    let movedMarker = movedMarkers.find(function(movedMarker) {
        return movedMarker.options.unique_id === marker.options.unique_id;
    });
    if (movedMarker) {
        // is path already drawn?
        if (positionChangeTracker[movedMarker.options.unique_id]) {
            // remove path
            removePositionChangeTrackingByUniqueId(marker.options.unique_id);
        } else{
            // draw path
            drawOriginalMarkerLocation(movedMarker, marker);
        }
       

    } else {
        //console.log("No Moved Marker Found for: ", marker.options.unit_name);
    }
    // restore default function
    map.dragging.enable();
}

function bubbleShowRangeRing(marker) {
    toggleRangeRingVisibility(marker);
    // restore default function
    map.dragging.enable();
}
// this function is for the individual unit range rings
function toggleRangeRingVisibility(marker) {
    if (marker.options.attached_polygons && marker.options.attached_polygons.length > 0) {
        marker.options.attached_polygons.forEach(function(rangeRing) {
            if (map.hasLayer(rangeRing)) {
                map.removeLayer(rangeRing);
            } else {
                rangeRing.addTo(map);
            }
        });
    }
}

// Function to calculate an offset based on zoom level
function calculateOffset(map, latlng, xOffset, yOffset) {
    // Convert latlng to layer point (pixel coordinates)
    var point = map.latLngToLayerPoint(latlng);
    // Apply the offset in pixel space
    point.x += xOffset;
    point.y += yOffset;
    // Convert the point back to latlng (geographical coordinates)
    return map.layerPointToLatLng(point);
}

var markerBubbles = [];

function showBubbles(marker) {
    //console.log('Showing Bubbles');
    //console.log(marker);
    var latlng = marker.getLatLng();

    // Get the icon size from the marker's options (assuming it has an icon)
    var iconSize = marker.options.icon.options.iconSize;
    var iconWidth = iconSize[0]; // width of the icon in pixels
    var iconHeight = iconSize[1]; // height of the icon in pixels

    // Calculate offsets dynamically based on the icon size
    var xOffset = iconWidth / 2 + 10; // Horizontal offset (half the icon width plus some padding)
    var yOffset = iconHeight / 2 + 10; // Vertical offset (half the icon height plus some padding)

    // Calculate new positions for the context menu bubbles
    var pathBubbleLatLng = calculateOffset(map, latlng, -xOffset, yOffset); // Left bubble
    var rangeRingBubbleLatLng = calculateOffset(map, latlng, xOffset, yOffset); // Right bubble
    var rotateBubbleLatLng = calculateOffset(map, latlng, 0, -yOffset); // Top bubble


    var pathBubble = L.marker(pathBubbleLatLng, {icon: pathMarker, pmIgnore: true, zIndexOffset: 1000});
    // make interactive
    pathBubble.options.interactive = true;
    pathBubble.options.unique_id = marker.options.unique_id;
    pathBubble.type = "context-menu";
    pathBubble.addTo(map);
    markerBubbles.push(pathBubble);

    var rangeRingBubble = L.marker(rangeRingBubbleLatLng, {icon: rangeRingMarker, pmIgnore: true, zIndexOffset: 1000});
    // make interactive
    rangeRingBubble.options.interactive = true;
    rangeRingBubble.options.unique_id = marker.options.unique_id;
    rangeRingBubble.type = "context-menu";
    rangeRingBubble.addTo(map);
    markerBubbles.push(rangeRingBubble);

    var rotateBubble = L.marker(rotateBubbleLatLng, {icon: rotateMarker, pmIgnore: true, zIndexOffset: 1000});
    // make interactive
    rotateBubble.options.interactive = true;
    rotateBubble.options.unique_id = marker.options.unique_id;
    rotateBubble.type = "context-menu";
    rotateBubble.addTo(map);
    markerBubbles.push(rotateBubble);
    

    wrapImginDiv();
    
    // Example function for when bubble1 is clicked
    pathBubble.on('click', function(e) {
        if (e.originalEvent) {
            e.originalEvent.preventDefault(); // Prevent default action on the original DOM event
        }
        if (selectedMarkers.length > 0) {
            selectedMarkers.forEach(function(marker) {
                bubbleShowPath(marker);
            });
        } else {
            bubbleShowPath(marker);
        }
        
    });

    // Example function for when bubble2 is clicked
    rangeRingBubble.on('click', function(e) {
        if (e.originalEvent) {
            e.originalEvent.preventDefault(); // Prevent default action on the original DOM event
        }
        if (selectedMarkers.length > 0) {
            selectedMarkers.forEach(function(marker) {
                bubbleShowRangeRing(marker);
            });
        } else {
            bubbleShowRangeRing(marker);
        }
    });

    rotateBubble.on('mousedown', function(e) {
        //console.log(e)
        if (e.originalEvent) {
            e.originalEvent.preventDefault();
        }
        
        if (selectedMarkers.length > 0) {
            selectedMarkers.forEach(function(marker) {
                bubbleRotate(marker, e, e.latlng); // Start rotation for each selected marker
            });
        } else {
            bubbleRotate(marker, e);
        }
    });

    rotateBubble.on('contextmenu', function(e) {
        if (e.originalEvent) {
            e.originalEvent.preventDefault();
        }
        // reset rotation
        if (selectedMarkers.length > 0) {
            selectedMarkers.forEach(function(marker) {
                marker.setRotationAngle(0);
                marker.options.rotationAngle = 0;
            });
        } else {
            marker.setRotationAngle(0);
            marker.options.rotationAngle = 0;
        }
    });

}


function bubbleRotate(marker, e, fixedPoint=undefined) {
    // Function to handle the mouse move event
    function onMouseMove(e) {
        var mouseLatLng = e.latlng; // Current mouse position
        if (fixedPoint) {   // this is a temp fix until i can figure out how to do a relative angle, pointing all markers to the same point
            var startLatLng = fixedPoint; // Get the marker's initial position
        } else {
            var startLatLng = marker.getLatLng(); // Get the marker's initial position
        }
        var angle = calculateAngle(startLatLng, mouseLatLng); // Calculate the rotation angle

        marker.setRotationAngle(angle); // Apply the rotation
        marker.options.rotationAngle = angle; // Store the rotation angle in the marker's options
    
    }

    // Function to stop the rotation on mouse up
    function onMouseUp() {
        map.off('mousemove', onMouseMove); // Stop tracking mouse movement
        map.off('mouseup', onMouseUp); // Stop listening for mouse up
    }

    // Start tracking mouse movement
    map.on('mousemove', onMouseMove);
    map.on('mouseup', onMouseUp);
}

function calculateAngle(startLatLng, mouseLatLng) {
    var dx = mouseLatLng.lng - startLatLng.lng;
    var dy = mouseLatLng.lat - startLatLng.lat;
    var angle = Math.atan2(dy, dx) * 180 / Math.PI; // Convert radians to degrees

    if (angle < 0) {
        angle += 360; // Ensure the angle is positive
    }

    return angle + 90;
}

function clearRangeRings() {
    map.eachLayer(function(layer) {
        if (layer instanceof L.Circle && layer.options.marker_type === "range_ring") {
            map.removeLayer(layer);
        }
    });
}

// alias
function clearPaths() {
    removeAllOriginalPaths();
}

function removeMarkerBubbles() {
    // remove all bubbles using markerBubbles
    markerBubbles.forEach(function(layer) {
        if (layer instanceof L.Marker) {
            if (layer.options.icon.options.className === 'path-marker' ||
                layer.options.icon.options.className === 'range-ring-marker' ||
                layer.options.icon.options.className === 'rotate-marker') {
                map.removeLayer(layer);
            }
        }
    });
    // Remove all instances of elements with specific class names
    ['range-ring-marker-div', 'path-marker-div', 'bubble-marker-div'].forEach(function(className) {
        var elements = document.getElementsByClassName(className);
        Array.from(elements).forEach(function(element) {
            element.remove();
        });
    });

    map.dragging.enable();

}


function resetAllMarkerRotationAngles(marker) {
    allUnitMarkers.forEach(function(marker) {
        marker.setRotationAngle(0);
        marker.options.rotationAngle = 0;
    });

}


function clearAllPlanningMarkers() {
    removeMarkerBubbles();
    clearRangeRings();
    clearPaths();
    // clear range rings selection
    // get the range rings switcher select element div.range-rings-switcher
    var divElem = document.querySelector('div.range-rings-switcher');
    // get the input checkboxes
    var checkboxes = divElem.querySelectorAll('input[type="checkbox"]');
    // uncheck all checkboxes
    checkboxes.forEach(function(checkbox) {
        checkbox.checked = false;
    });

    // clear logistics rings selection
    // get the range rings switcher select element div.log-rings-switcher
    var divElem = document.querySelector('div.log-rings-switcher');
    // get the input checkboxes
    var checkboxes = divElem.querySelectorAll('input[type="checkbox"]');
    // uncheck all checkboxes
    checkboxes.forEach(function(checkbox) {
        checkbox.checked = false;
    });


}


function wrapImginDiv() {
    var classList = ["range-ring-marker", "path-marker", "rotate-marker"];
    classList.forEach(function(className) {
        var elements = document.getElementsByClassName(className);
        Array.from(elements).forEach(function(element) {
            var div = document.createElement('div');
            div.className = className+"-div";
            element.parentNode.insertBefore(div, element);
            div.appendChild(element);
        });
    });
}



var pathMarker = L.icon({
    iconUrl: '/static/img/path-marker.png',
    iconSize: [25, 25], // size of the icon
    className: 'path-marker',
});

var rangeRingMarker = L.icon({
    iconUrl: '/static/img/range-ring-marker.png',
    iconSize: [25, 25], // size of the icon
    className: 'range-ring-marker',
});

var cancelMarker = L.icon({
    iconUrl: '/static/img/cancel-marker.png',
    iconSize: [25, 25], // size of the icon
    className: 'cancel-marker',
});

var rotateMarker = L.icon({
    iconUrl: '/static/img/rotate-marker.png',
    iconSize: [25, 25], // size of the icon
    className: 'rotate-marker',
});

// this function is for air defense range rings, not for unit range rings (non air defense)
function drawAttachedRangeRings(marker) {
    //console.log(`Drawing Range Rings for: ${marker.options.unique_id}:${marker.options.unit_name}`, );
    // Get the marker's position
    var ringColor = 'red';
    var markerPosition = marker.getLatLng();
    var effectsRadius = marker.options.effects_radius_nm;
    var rangeRing = L.circle(markerPosition, {
        radius: convertDistance(effectsRadius, 'nm'), // Convert nautical miles to meters
        color: ringColor, // Stroke color
        fillColor: ringColor, // Fill color
        fillOpacity: 0.1, // Fill opacity
        weight: 1, // Stroke width
        dashArray: '10, 10', // Dashes and gaps pattern: 10px dash, 10px gap
        unit_type: marker.options.unit_type,
        marker_type: "range_ring",
        pmIgnore: true,
        //editable: false, // do not allow editing
        //draggable: false, // do not allow dragging
        
    });
    marker.options.rangeRingGroup = rangeRing;

    // give popup to range ring
    let rangeRingPopup = marker.options.unit_name + " - Range: " + marker.options.effects_radius_nm + "nm";
    rangeRing.bindPopup(rangeRingPopup);

    // Add to the layer group instead of directly to the map
    //rangeRing.addTo(rangeRingsLayerGroup);
    if (rangeRingsLayerGroupTracker[marker.options.country] == undefined) {
        rangeRingsLayerGroupTracker[marker.options.country] = L.layerGroup();
    }
    rangeRing.addTo(rangeRingsLayerGroupTracker[marker.options.country]);
    
    marker.options.attached_polygons.push(rangeRing);
    

}

function hideRangeRing(marker) {
    marker.options.rangeRingGroup.setStyle({fillOpacity: 0});
    marker.options.rangeRingGroup.setStyle({weight: 0});
}

function showRangeRing(marker) {
    marker.options.rangeRingGroup.setStyle({fillOpacity: 0.1});
    marker.options.rangeRingGroup.setStyle({weight: 1});
}


// Show all markers with a certain unit_type: opacity 1
function showMarkersByUnitType(unitType) {
    map.eachLayer(function(layer) {
        if (layer instanceof L.Marker && layer.options.unit_type === unitType) {
            layer.setOpacity(1);
            if (layer.options.rangeRingGroup) {
                showRangeRing(layer);
            }
            layer.options.hidden = false;
            toggleLayerInteractions(layer, true);
        }
    });
}



// Show markers by domain
function showMarkersByDomain(domain) {
    map.eachLayer(function(layer) {
        if (layer instanceof L.Marker && layer.options.domain === domain) {
            layer.setOpacity(1);
            if (layer.options.rangeRingGroup) {
                showRangeRing(layer);
            }
            layer.options.hidden = false;
            toggleLayerInteractions(layer, true);
        }
    });
}


// Show markers by country
function showMarkersByCountry(country) {
    map.eachLayer(function(layer) {
        if (layer instanceof L.Marker && layer.options.country === country) {
            layer.setOpacity(1);
            if (layer.options.rangeRingGroup) {
                showRangeRing(layer);
            }
            layer.options.hidden = false;
            toggleLayerInteractions(layer, true);
        }
    });
}

// Show all markers
function showAllMarkers() {
    map.eachLayer(function(layer) {
        if (layer instanceof L.Marker) {
            if (layer.options.rangeRingGroup) {
                showRangeRing(layer);
            }
            layer.setOpacity(1);
            layer.options.hidden = false;
            toggleLayerInteractions(layer, true);
        }
    });
}

// Hide markers by country
function hideMarkersByCountry(country) {
    map.eachLayer(function(layer) {
        if (layer instanceof L.Marker && layer.options.country === country) {
            layer.setOpacity(0);
            if (layer.options.rangeRingGroup) {
                hideRangeRing(layer);
            }
            layer.options.hidden = true;
            toggleLayerInteractions(layer, false);
            deselectItem(layer);
        }
    });
    updateTableUniqueIDFilter();
}

// Hide markers by domain
function hideMarkersByDomain(domain) {
    map.eachLayer(function(layer) {
        if (layer instanceof L.Marker && layer.options.domain === domain) {
            layer.setOpacity(0);
            if (layer.options.rangeRingGroup) {
                hideRangeRing(layer);
            }
            layer.options.hidden = true;
            toggleLayerInteractions(layer, false);
            deselectItem(layer);
        }
    });
    updateTableUniqueIDFilter();
}

function hideMarkersByUnitType(unitType) {
    map.eachLayer(function(layer) {
        if (layer instanceof L.Marker && layer.options.unit_type === unitType) {
            layer.setOpacity(0);
            if (layer.options.rangeRingGroup) {
                hideRangeRing(layer);
            }
            layer.options.hidden = true;
            toggleLayerInteractions(layer, false);
            deselectItem(layer);
        }
    });
    updateTableUniqueIDFilter();
}

// Hide all markers
function hideAllMarkers() {
    map.eachLayer(function(layer) {
        if (layer instanceof L.Marker) {
            layer.setOpacity(0);
            layer.options.hidden = true;
            toggleLayerInteractions(layer, false);
        }
    });
    deselectMarkers();
    //updateTableUniqueIDFilter();
}

function hideMarkersByLayerName(LayerName) {
    
    if (globalLayerAssignments[LayerName]) {
        console.log("Hiding Markers by Layer Name:", LayerName);
        // Set the visibility flag to false
        globalLayerAssignments[LayerName].visible = false;

        globalLayerAssignments[LayerName].markers.forEach(function(marker) {
            if (marker instanceof L.Marker) {
                marker.setOpacity(0);
                if (marker.options.rangeRingGroup) {
                    hideRangeRing(marker);
                }
                marker.options.hidden = true;
                toggleLayerInteractions(marker, false);
                deselectItem(marker);
            }
        });
    } else {
        console.error("Layer Name not found in globalLayerAssignments:", LayerName);
    }
}

function hideTextMarkersByLayerName(layerName) {
    console.log("Hiding Text Markers by Layer Name:", layerName);
    if (globalLayerAssignments[layerName]) {
        // Set the visibility flag to false
        globalLayerAssignments[layerName].visible = false;

        // Hide text markers
        globalLayerAssignments[layerName].textMarkers.forEach(function(textMarker) {
            if (textMarker instanceof L.Marker && textMarker.options.textMarker) {
                textMarker.setOpacity(0);
                textMarker.options.hidden = true;
                toggleLayerInteractions(textMarker, false);
                deselectItem(textMarker);
            }
        });
    }
}


function hidePolygonsByLayerName(LayerName) {
    console.log("Hiding Polygons by Layer Name:", LayerName);
    if (globalLayerAssignments[LayerName]) {
        // Set the visibility flag to false
        globalLayerAssignments[LayerName].visible = false;

        globalLayerAssignments[LayerName].polygons.forEach(function(polygon) {
            //if (polygon instanceof L.Polygon) {
            //    polygon.setStyle({opacity: 0, fillOpacity: 0});
            //    polygon.options.hidden = true;
            //}
            polygon.setStyle({opacity: 0, fillOpacity: 0});
            polygon.options.hidden = true;
            toggleLayerInteractions(polygon, false);
            deselectPolygon(polygon);
            // if part of lrf, hide all
            if (polygon.options.isLRF) {
                hideLRF(polygon);
            }
        });
    }
}

function hideLRF(polygon) {
    //console.log("Hiding LRF");
    // get all polygons with the same unique_id
    var lrf_object = lrfLayerGroups[polygon.options.lrfLayerId]
    if (lrf_object) {
        // loop through the keys in lrf_object._layers
        for (var key in lrf_object._layers) {
            // get the polygon
            var lrf_polygon = lrf_object._layers[key];
            // hide the polygon
            lrf_polygon.setStyle({opacity: 0, fillOpacity: 0});
            lrf_polygon.options.hidden = true;
            toggleLayerInteractions(lrf_polygon, false);
            deselectPolygon(lrf_polygon);
        }
    }
}

function showLRF(polygon) {
    //console.log("Showing LRF");
    // get all polygons with the same unique_id
    var lrf_object = lrfLayerGroups[polygon.options.lrfLayerId]
    if (lrf_object) {
        // loop through the keys in lrf_object._layers
        for (var key in lrf_object._layers) {
            // get the polygon
            var lrf_polygon = lrf_object._layers[key];
            // show the polygon
            lrf_polygon.setStyle({opacity: 1, fillOpacity: 0.5});
            lrf_polygon.options.hidden = false;
            toggleLayerInteractions(lrf_polygon, true);
        }
    }
}

function showTextMarkersByLayerName(layerName) {
    console.log("Showing Text Markers by Layer Name:", layerName);
    if (globalLayerAssignments[layerName]) {
        // Set the visibility flag to true
        globalLayerAssignments[layerName].visible = true;

        // Show text markers
        globalLayerAssignments[layerName].textMarkers.forEach(function(textMarker) {
            if (textMarker instanceof L.Marker && textMarker.options.textMarker) {
                textMarker.setOpacity(1);
                textMarker.options.hidden = false;
                toggleLayerInteractions(textMarker, true);
            }
        });
    }
}

function showMarkersByLayerName(LayerName) {
    console.log("Showing Markers by Layer Name:", LayerName);
    if (globalLayerAssignments[LayerName]) {
        // Set the visibility flag to true
        globalLayerAssignments[LayerName].visible = true;

        globalLayerAssignments[LayerName].markers.forEach(function(marker) {
            if (marker instanceof L.Marker) {
                marker.setOpacity(1);
                if (marker.options.rangeRingGroup) {
                    showRangeRing(marker);
                }
                marker.options.hidden = false;
                toggleLayerInteractions(marker, true);
            }
        });
    }
}


function showPolygonsByLayerName(layerName) {
    console.log("Showing Polygons by Layer Name:", layerName);
    if (globalLayerAssignments[layerName]) {
        // Set the visibility flag to true
        globalLayerAssignments[layerName].visible = true;

        globalLayerAssignments[layerName].polygons.forEach(function(polygon) {

            polygon.setStyle({ opacity: 1, fillOpacity: 0.5 }); // Adjust fillOpacity as needed
            if (polygon.options.shape) {
                toggleLayerInteractions(polygon, true);
            }
            polygon.options.hidden = false;
            if (polygon.options.isLRF) {
                showLRF(polygon);
            }
        });
    }
}


function toggleLayerInteractions(layer, interactive) {
    try {
        if (interactive) {
            layer.dragging.enable();
            layer.getElement().classList.add('pointer'); // Add pointer style
            layer.getElement().classList.add('leaflet-interactive'); // Add interactive style
            // attach popup
            layer.bindPopup(layer.options.popupContent);
        } else {
            layer.dragging.disable();
            layer.getElement().classList.remove('pointer'); // Remove pointer style
            layer.getElement().classList.remove('leaflet-interactive'); // Remove interactive style
            // detatch popup
            layer.unbindPopup();
            layer.setPopupContent(null);
            deselectItem(layer);
            deselectPolygon(layer);
        }
    } catch (error) {
        //console.error("Error Toggling Layer Interactions: ", error);
        //console.error("Layer: ", layer);
    }
}

function synchronizeLayersVisibility() {
    console.log("Synchronizing Layer Visibility");
    for (let layerName in globalLayerAssignments) {
        let items = globalLayerAssignments[layerName];
        if (items.markers.length > 0) {
            if (items.markers[0].options.hidden) {
                globalLayerAssignments[layerName].visible = false;
            } else {
                globalLayerAssignments[layerName].visible = true;
            }
            continue;
        }
        if (items.polygons.length > 0) {
            if (items.polygons[0].options.hidden) {
                globalLayerAssignments[layerName].visible = false;
            } else {
                globalLayerAssignments[layerName].visible = true;
            }
            continue;
        }
        if (items.textMarkers.length > 0) {
            if (items.textMarkers[0].options.hidden) {
                globalLayerAssignments[layerName].visible = false;
            } else {
                globalLayerAssignments[layerName].visible = true;
            }
            continue;
        }
                
    }
}



function deleteLayer(layerName) {
    // Ensure the layer exists
    if (!globalLayerAssignments[layerName]) {
        console.log(`Layer "${layerName}" does not exist.`);
        return;
    }

    // Get all objects in the layer
    let layer = globalLayerAssignments[layerName];

    // Helper function to remove the layerName from the assignedLayers of each item
    function unassignLayer(item, layerName) {
        let index = item.options.assignedLayers.indexOf(layerName);
        if (index > -1) {
            item.options.assignedLayers.splice(index, 1); 
        }

    }

    // Remove the layerName from markers, polygons, and textMarkers
    layer.markers.forEach(item => unassignLayer(item, layerName));
    layer.polygons.forEach(item => unassignLayer(item, layerName));
    layer.textMarkers.forEach(item => unassignLayer(item, layerName));

    // make all markers visible
    try {
        showMarkersByLayerName(layerName);
    } catch (error) {
    }
    try {
        showPolygonsByLayerName(layerName);
    } catch (error) {
    }
    try {
        showTextMarkersByLayerName(layerName);
    } catch (error) {
    }


    // Delete the layer from globalLayerAssignments
    delete globalLayerAssignments[layerName];

    console.log(`Layer "${layerName}" deleted.`);
}



// this deselects all markers
function deselectMarkers() {
    // Clone the array to avoid modifying it while iterating
    let markersToDeselect = [...selectedMarkers];
    markersToDeselect.forEach(function(marker) {
        //console.log("Deselecting Marker: ", marker.options.unique_id);
        deselectItem(marker);
    });
    selectedMarkers = [];
    clearFilters();
    
    // Handle polygons
    let polygonsToDeselect = [...selectedShapes];
    polygonsToDeselect.forEach(function(polygon) {
        deselectItem(polygon);
    });
    selectedShapes = [];
    
    // Handle text markers
    let textMarkersToDeselect = [...selectedTextMarkers];
    textMarkersToDeselect.forEach(function(textMarker) {
        deselectItem(textMarker);
    });
    selectedTextMarkers = [];
}

function invertSelection() {
    // Clone the selected array
    let markersToDeselect = [...selectedMarkers];
    // Select all markers and shapes
    map.eachLayer(function(layer) {
        if (layer instanceof L.Marker) {
            if (!selectedMarkers.includes(layer)) {
                selectItem(layer);
            } else {
                deselectItem(layer);
            }
        } else if (layer instanceof L.Polygon || layer instanceof L.Polyline) {
            if (!selectedShapes.includes(layer)) {
                selectItem(layer);
            } else {
                deselectItem(layer);
            }
        }
    });

    // deselect specific markers
    markersToDeselect.forEach(function(marker) {
        deselectItem(marker);
    });

}

function selectItem(item) {
    // Handle selection for markers
    if (item instanceof L.Marker && !item.options.textMarker) {
        console.log("Selected Marker: ", item.options.unique_id);
        if (!selectedMarkers.includes(item)) {
            selectedMarkers.push(item);
            updateMarkerStyle(true, item);
            //console.log("Selected Marker: ", item.options.unique_id);
        }
    } 
    // Handle selection for polygons
    else if (item instanceof L.Polygon || item instanceof L.Polyline) {
        console.log("Selected Polygon/Line: ", item.options.unique_id);
        if (!selectedShapes.includes(item)) {
            selectedShapes.push(item);
            updateShapeStyle(true, item);
            //console.log("Selected Polygon: ", item.options.unique_id);
        }
    }
    // Handle selection for text markers
    else if (item instanceof L.Marker && item.options.textMarker) {
        console.log("Selected Text Marker: ", item.options.unique_id);
        if (!selectedTextMarkers.includes(item)) {
            selectedTextMarkers.push(item);
            updateMarkerStyle(true, item);
            //console.log("Selected Text Marker: ", item.options.unique_id);
        }
    }
}

function deselectItem(item) {
    var index;
    // Handle deselection for markers
    if (selectedMarkers.includes(item)) {
        //console.log("Trying to Deselect Marker: ", item.options.unique_id);
        index = selectedMarkers.indexOf(item);
        if (index > -1) {
            selectedMarkers.splice(index, 1);
            updateMarkerStyle(false, item);
            //console.log("Deselected Marker: ", item.options.unique_id);
        }
    } 
    else if (selectedTextMarkers.includes(item)) {
        index = selectedTextMarkers.indexOf(item);
        if (index > -1) {
            selectedTextMarkers.splice(index, 1);
            updateMarkerStyle(false, item);
            //console.log("Deselected Text Marker: ", item.options.unique_id);
        }
    }
    // Handle deselection for polygons
    else if (selectedShapes.includes(item)) {
        index = selectedShapes.indexOf(item);
        if (index > -1) {
            selectedShapes.splice(index, 1);
            updateShapeStyle(false, item);
            //console.log("Deselected Polygon: ", item.options.unique_id);
        }
    }

}


function deselectPolygon(polygon) {
    if (selectedShapes.includes(polygon)) {   
        const index = selectedShapes.indexOf(polygon);
        if (index > -1) {
            selectedShapes.splice(index, 1);
            updateShapeStyle(false, polygon);
            console.log("Deselected Polygon: ", polygon.options.unique_id);
        }
    }

}

function updateTableUniqueIDFilter() {
    console.log("Updating Table Unique ID Filter");
    if (selectedMarkers.length === 0) {
        const uniqueIdColumnIndex = 0; // this is the unique_id column index
        selectedMarkersByUniqueID = selectedMarkers.map(marker => marker.options.unique_id);
        filterDataTableByUniqueIds(selectedMarkersByUniqueID, uniqueIdColumnIndex);
    } else {
        clearFilters();
    }
}

// Return marker by unique_id
function getMarkerByUniqueId(uniqueId) {
    return originalMarkers.find(function(marker) {
        return marker.options.unique_id === uniqueId;
    });
}



// this function applies to all range rings with a unit_type of "air defense"
function toggleRangeRingLayerVisibility(team) {
    if (rangeRingsLayerGroupTracker[team]) {
        if (map.hasLayer(rangeRingsLayerGroupTracker[team])) {
            map.removeLayer(rangeRingsLayerGroupTracker[team]);
        } else {
            rangeRingsLayerGroupTracker[team].addTo(map);
        }
    }
}

function toggleLogRingLayerVisibility(team) {
    if (logRingsLayerGroupTracker[team]) {
        if (map.hasLayer(logRingsLayerGroupTracker[team])) {
            map.removeLayer(logRingsLayerGroupTracker[team]);
        } else {
            logRingsLayerGroupTracker[team].addTo(map);
        }
    }
}

// TODO: this function needs to be merged
function drawUnitAttachedRangeRings(marker) {
    // Get the marker's position
    //console.log(`Drawing Range Rings for: ${marker.options.unique_id}:${marker.options.unit_name}`, );
    var ringColor = 'grey';
    if (marker.options.unit_type.toLowerCase().includes("sustainment")){
        ringColor = 'green';
    }
    
    var markerPosition = marker.getLatLng();
    var effectsRadius = marker.options.effects_radius_nm;
    var unitRangeRing = L.circle(markerPosition, {
        radius: convertDistance(effectsRadius, 'nm'), // Convert nautical miles to meters
        color: ringColor, // Stroke color
        fillColor: ringColor, // Fill color
        fillOpacity: 0.1, // Fill opacity
        weight: 1, // Stroke width
        dashArray: '2, 5, 4, 1', // Dashes and gaps pattern: 10px dash, 10px gap
        unit_type: marker.options.unit_type,
        marker_type: "range_ring",
        pmIgnore: true,
        //editable: false, // do not allow editing
        //draggable: false, // do not allow dragging
        
    });

    // give popup to range ring
    let unitRangeRingPopup = marker.options.unit_name + " - Range: " + marker.options.effects_radius_nm + "nm";
    unitRangeRing.bindPopup(unitRangeRingPopup);

    // Add to the layer group instead of directly to the map
    //unitRangeRing.addTo(unitRangeRingsLayerGroup);
    //unitRangeRing.addTo(map);
    marker.options.attached_polygons.push(unitRangeRing);
    
    if (marker.options.unit_type.toLowerCase().includes("sustainment")){
        marker.options.rangeRingGroup = unitRangeRing;
        if (logRingsLayerGroupTracker[marker.options.country] == undefined) {
            logRingsLayerGroupTracker[marker.options.country] = L.layerGroup();
        }
        unitRangeRing.addTo(logRingsLayerGroupTracker[marker.options.country]);
    }
}


function removeAllRangeRingsFromMap() {
    map.eachLayer(function(layer) {
        // if marker has .attached_polygons
        if (layer instanceof L.Circle && layer.options.unit_type) {
            map.removeLayer(layer);
        }
    });
}

function removeAllPositionChangeTracking() {
    // Loop through all markers and remove the position change tracking - positionChangeTracker
    originalMarkers.forEach(function(marker) {
        removePositionChangeTrackingByUniqueId(marker.options.unique_id);
    });
}

function updatePopupDetails(marker) {
    //console.log("Updating Popup Details for: ", marker.options.unit_name);
    //console.log("Old Popup Content: ", marker.getPopup().getContent());
    let lat = marker.getLatLng().lat.toFixed(6);
    let lng = marker.getLatLng().lng.toFixed(6);
    marker.options.latitude = lat;
    marker.options.longitude = lng;
    let popupContent = marker.options.details;
    let newPopupContent = popupContent.replace(/<i> Coords: [0-9.]+, [0-9.]+<\/i><br>/, "<i> Coords: " + lat + ", " + lng + "</i><br>");
    
    marker.options.customPopupContent = newPopupContent;    

}

function updateRangeRings(marker) {
    // check if marker has range rings
    if (marker.options.attached_polygons.length === 0) {
        return;
    }
    //console.log("Updating Range Rings for: ", marker.options.unit_name);
    // Remove any existing range rings
    marker.options.attached_polygons.forEach(polygon => {
        // set the new lat long
        polygon.setLatLng(marker.getLatLng());
    });
    
}

function calculateScaleFactor(zoomLevel) {
    // Implement your logic here to determine scaleFactor based on zoomLevel.
    // This is a simple example that linearly adjusts the scale; you may want a non-linear scale.
    var baseZoom = 10; // Adjust this base zoom level according to your needs.
    return zoomLevel / baseZoom;
}




function calculateDistFactor(currentZoom) {
    const baseFactor = 0.03; // Base separation factor for control
    const zoomExponent = 1.5; // Exponential factor for lower zoom levels
    const highZoomAdjustment = 0.2; // Fixed adjustment for high zoom levels to prevent overlap

    // Adjust distFactor based on zoom level
    let distFactor;
    if (currentZoom <= 12) {
        // Exponential increase for zoom levels <= 12
        distFactor = baseFactor * Math.pow(currentZoom, zoomExponent);
    } else {
        // For zoom levels > 12, apply a fixed adjustment to avoid overlap
        // You can also experiment with a formula that slightly decreases distFactor as zoom increases beyond 12
        distFactor = highZoomAdjustment + ((currentZoom - 12) * (baseFactor / 1000));
    }

    return distFactor;
}

function isSIDC(str) {
    return /^\d{20}$/.test(str) || /^\d{20}_[a-zA-Z0-9]+$/.test(str);
}


function isValidUrl(string) {
    let url;
  
    try {
      url = new URL(string);
    } catch (_) {
      return false;  
    }
  
    return url.protocol === "http:" || url.protocol === "https:" || url.protocol === "ftp:" || url.protocol === "file:";
  }

function setupMarkerHandlers(marker, drag_bool) {
    //console.log("Setting up marker handlers for marker: ", marker);
    //marker.bindPopup(marker.options.details, {autoClose: false, closeOnClick: false});
    if (drag_bool) {
        marker.on('dragstart', function(e) {
            onDragStart(e);
        });

        marker.on('drag', function(e) {
            onDrag(e); 
        });

        marker.on('dragend', function(e) {
            onDragEnd(e); // You'll implement the detailed logic for onDragEnd as needed
        });
    }
    marker.on('click', function(e) {
        marker.unbindPopup();
        toggleMarkerSelection(e);
    });
    marker.on('dblclick', function(e) {
        updatePopupDetails(marker);
        marker.bindPopup(marker.options.customPopupContent);
        marker.openPopup();
    });
}

function setupPolygonHandlers(polygon) {
    polygon.on('click', function(e) {
        toggleShapeSelection(e);
    });
    polygon.on('dblclick', function(e) {
        L.DomEvent.stopPropagation(e);
        var colorPicker = document.getElementById('color-picker');
        if (colorPicker) {
            layer.setStyle({ color: colorPicker.value });
        }
    });
}


let bulkMoveInfo = {};

function initializeMarkerMovementInfo(markers) {
    markers.forEach(marker => {
        let unitType = marker.options.unit_type;
        //let originalPosition = marker.getLatLng();
        originalPosition = new L.LatLng(marker.options.latitude, marker.options.longitude);
        let maxDistance = null; // Default to null indicating not found or unlimited

        if (typeof jsonDataMovementArray !== 'undefined') {
            jsonDataMovementArray.forEach(movementRule => {
                if (unitType === movementRule.unit_type) {
                    // Find the key that includes "distance_rule"
                    for (let key in movementRule) {
                        if (key.includes("distance_rule")) {
                            let ruleDistance = movementRule[key]; // Use the dynamic key to access the value
                            // if -1 unlimited distance
                            if (ruleDistance == -1){
                                maxDistance = null;
                                break;
                            } else {
                                let ruleUnitOfMeasure = movementRule.unit_of_measure;
                                //console.log("ruleDistance:", ruleDistance, "ruleUnitOfMeasure:", ruleUnitOfMeasure);
                                maxDistance = convertDistance(ruleDistance, ruleUnitOfMeasure);
                                break; // Exit the loop after finding the first matching key
                        
                            }
                        }
                    }
                }
            });
        } else {
            //console.error("No movement rules found for marker", marker.options.unique_id);
            maxDistance = null;
        }
        // Initialize with both originalPosition and a duplicate as lastKnownGoodPosition
        bulkMoveInfo[marker.options.unique_id] = {
            originalPosition, 
            maxDistance,
            lastKnownGoodPosition: originalPosition // Initialize lastKnownGoodPosition
        };
    });
}

function onDrag(e) {
    let draggedMarker = e.target; // The marker being dragged.
    let uniqueId = draggedMarker.options.unique_id; // Unique ID of the dragged marker.
    let currentLatLng = draggedMarker.getLatLng(); // Current position of the dragged marker.

    // Retrieve stored information for the dragged marker.
    let info = bulkMoveInfo[uniqueId];
    if (!info) {
        console.error("Missing information for marker", uniqueId);
        return; // Exit if the necessary information isn't stored.
    }

    if (selectedMarkers.length > 1) {
        let deltaLat = currentLatLng.lat - info.originalPosition.lat;
        let deltaLng = currentLatLng.lng - info.originalPosition.lng;

        // Attempt to apply the delta to each selected marker.
        selectedMarkers.forEach(selectedMarker => {
            
            selectedMarker.dragging.enable();
            let selectedMarkerId = selectedMarker.options.unique_id;
            let selectedMarkerInfo = bulkMoveInfo[selectedMarkerId];

            // Calculate new position based on the delta.
            let newLat = selectedMarkerInfo.originalPosition.lat + deltaLat;
            let newLng = selectedMarkerInfo.originalPosition.lng + deltaLng;
            let newLatLng = L.latLng(newLat, newLng);

            // Check the distance from the original position to the new position.
            let distanceFromOriginal = selectedMarkerInfo.originalPosition.distanceTo(newLatLng);

            if (selectedMarkerInfo.maxDistance == null || distanceFromOriginal <= selectedMarkerInfo.maxDistance) {
                // Movement is within allowed distance, apply it.
                selectedMarker.setLatLng(newLatLng);
                
                // if there are attached polygons update them
                if (selectedMarker.options.attached_polygons.length > 0) {
                    updateRangeRings(selectedMarker);
                }

                // Update this position as the new lastKnownGoodPosition.
                selectedMarkerInfo.lastKnownGoodPosition = newLatLng;
            } else {
                //console.log(`Movement exceeds max distance for marker ${selectedMarkerId}, not moving.`);
                // Optionally, revert to last known good position if the movement is not allowed.
                selectedMarker.setLatLng(selectedMarkerInfo.lastKnownGoodPosition);
            }
            
            // Update the position of range rings attached to the dragged marker.
            //updateRangeRings(selectedMarker);
            //addToMovedMarkers(selectedMarker);
        });
    } else {
        selectedMarkers[0].dragging.enable();
        // For single marker movement, just check against its maxDistance.
        let distanceFromOriginal = info.originalPosition.distanceTo(currentLatLng);
        if (info.maxDistance != null && distanceFromOriginal > info.maxDistance) {
            //console.log("Exceeds max distance, reverting to last known good position");
            draggedMarker.setLatLng(info.lastKnownGoodPosition);
        } else {
            info.lastKnownGoodPosition = currentLatLng;
        }
        draggedMarker.dragging.enable();
        //updateRangeRings(draggedMarker);
        //addToMovedMarkers(draggedMarker);
    }
}


function onDragStart(e) {
    console.log("Drag Start For: ", e.target);
    var marker = e.target;
    var uniqueId = marker.options.unique_id; // Assuming each marker has a unique ID set in its options.
    var currentLatLng = marker.getLatLng(); // Capture the start position for use in onDrag.

    startNewMove(); // Initialize a new move
    selectedMarkers.forEach(selectedMarker => {
        saveMovementInfo(selectedMarker); // Save the initial position for the current move
    });
    if (!selectedMarkers.includes(marker)) {
        selectedMarkers.push(marker);
    }

    // Initialize or update marker movement info including the start position.
    if (!bulkMoveInfo[uniqueId]) {
        // If there's no entry for this marker yet, initialize it.
        bulkMoveInfo[uniqueId] = {
            originalPosition: currentLatLng,
            lastKnownGoodPosition: currentLatLng,
            startLatLng: currentLatLng, // Set startLatLng here to ensure it's always initialized.
            maxDistance: null // You might want to set this based on your app's logic.
        };
    } else {
        // If there's already an entry, just update the startLatLng.
        bulkMoveInfo[uniqueId].startLatLng = currentLatLng;
        //console.log("Updating Start LatLng:", bulkMoveInfo[uniqueId].startLatLng);
    }
    initializeMarkerMovementInfo(selectedMarkers);
}

var moveHistoryTracker = []; // Array to track each bulk move
var moveHistoryTracker_PrevPos = [];
var currentMoveId = -1; // Initialize to -1 to indicate no move started
const movesLimit = 10; // Set the maximum number of moves to track

function startNewMove() {
    currentMoveId++; // Increment to create a new unique move ID
    console.log("Starting new move with ID:", currentMoveId);
    moveHistoryTracker[currentMoveId] = new Set(); // Initialize a new bulk move array
}

function saveMovementInfo(marker) {
    console.log("Saving Movement Info for: ", marker.options.unique_id);
    
    // Save the current marker position for the current move
    const lat = marker.getLatLng().lat;
    const lng = marker.getLatLng().lng;
    const savedMove = { 
        unique_id: marker.options.unique_id,
        position: [lat,lng], // Deep copy position
        angle: marker.options.rotationAngle,
        marker: marker
    };

    moveHistoryTracker[currentMoveId].add(savedMove);

    // Ensure we don't exceed the moves limit
    if (moveHistoryTracker.length > movesLimit) {
        moveHistoryTracker.shift(); // Remove the oldest move if limit exceeded
        currentMoveId--; // Adjust current move ID accordingly
    }
}

function finalizeMove() {
    console.log("Move finalized:", moveHistoryTracker[currentMoveId]);
}

function _resetMovementInfo() {
    moveHistoryTracker = [];
    currentMoveId = -1;
}

function _showMovementInfo() {
    console.log("Move History Tracker:", moveHistoryTracker);
    console.log("Current Move ID:", currentMoveId);
}

function undoMovements() {
    const lastMove = moveHistoryTracker[currentMoveId];
    if (!lastMove) {
        console.log("No moves to undo.");
        return;
    }

    // save current position for redo
    moveHistoryTracker_PrevPos[currentMoveId] = new Set();
    lastMove.forEach(move => {
        const lat = move.marker.getLatLng().lat;
        const lng = move.marker.getLatLng().lng;
        const savedMove = { 
            unique_id: move.unique_id,
            position: [lat,lng], // Deep copy position
            angle: move.marker.options.rotationAngle,
            marker: move.marker
        };
        moveHistoryTracker_PrevPos[currentMoveId].add(savedMove);
    });


    // cycle through all markers in the last move
    lastMove.forEach(move => {
        console.log("Undoing move for: ", move.unique_id);
        // Find the marker by unique_id
        let marker = getMarkerByUniqueId(move.unique_id);
        // set the marker position to the saved position
        const lat = move.position[0];
        const lng = move.position[1];
        marker.setLatLng([lat, lng]);
        // reset rotation angle
        marker.setRotationAngle(move.angle);
        console.log("Marker Position Reset: ", marker.getLatLng());
        // update the range rings
        updateRangeRings(marker);
    });
    currentMoveId--; // Decrement the current move ID
}

function redoMovements() {
    const nextMove = moveHistoryTracker_PrevPos[currentMoveId + 1];
    if (!nextMove) {
        console.log("No moves to redo.");
        return;
    }
    // cycle through all markers in the next move
    nextMove.forEach(move => {
        console.log("Redoing move for: ", move.unique_id);
        // Find the marker by unique_id
        let marker = getMarkerByUniqueId(move.unique_id);
        // set the marker position to the saved position
        const lat = move.position[0];
        const lng = move.position[1];
        marker.setLatLng([lat, lng]);
        marker.setRotationAngle(move.angle);
        console.log("Marker Position Reset: ", marker.getLatLng());
        // update the range rings
        updateRangeRings(marker);
    });
    currentMoveId++; // Increment the current move ID
}


function onDragEnd(e) {
    //console.log("Drag End");
    // Finalize the marker position, apply constraints, and perform any clean-up
    let marker = e.target;

    let uniqueId = marker.options.unique_id;
    let info = bulkMoveInfo[uniqueId];

    if (!info || !info.originalPosition) {
        console.error("Missing movement info for marker", uniqueId);
        return;
    }

    // Additional logic to handle marker finalization post-drag
    selectedMarkers.forEach(selectedMarker => {
        addToMovedMarkers(selectedMarker); // Update marker status
        updateMarkerStyle(true, selectedMarker); // Optionally update marker style
        //saveMovementInfo(selectedMarker)
        //console.log("Marker Dragged: ", selectedMarker);
    });
    updateRangeRings(marker); // Update range rings if needed
    // check if need to update antimeridian
    fixAntimeridianMarkers();
    finalizeMove(); // Finalize the move
}

function updateOpacityForStackedMarkers(markers) {
    markers.forEach(marker => {
        // Assuming 'markers' is an array of L.Marker instances
        const markerPos = marker.getLatLng();
        markers.forEach(otherMarker => {
            const otherMarkerPos = otherMarker.getLatLng();
            if (marker !== otherMarker && markerPos.equals(otherMarkerPos)) {
                // This checks if two markers are at the same position and not the same marker
                otherMarker.setOpacity(0.5); // Adjust as needed
            }
        });
    });
}


//function calculateIconSize(zoomLevel) {
    // Implement logic to determine icon size based on zoom level
    // This is just an example; adjust it according to your needs
//    return zoomLevel * 5; // Example formula 6 is default down is smaller
//}

function calculateIconSize(currentZoom) {
    const smallSize = 10; // Size for low zoom levels
    const mediumSize = 20; // Size for mid zoom levels
    const largeSize = 40; // Size for high zoom levels
    // low = zoomed out
    // high = zoomed in - high degree of magnification
    // Example zoom level thresholds for changing sizes
    const mediumZoomThreshold = 5; // Zoom level at which markers change from small to medium
    const largeZoomThreshold = 10; // Zoom level at which markers change from medium to large

    if (currentZoom < mediumZoomThreshold) {
        return smallSize*iconSizeFactor;
    } else if (currentZoom < largeZoomThreshold) {
        return mediumSize*iconSizeFactor;
    } else {
        return largeSize*iconSizeFactor;
    }
}

function addToMovedMarkers(marker) {
    // Find marker in movedMarkers by unique_id
    let index = movedMarkers.findIndex(movedMarker => movedMarker.unique_id === marker.options.unique_id);

    // Prepare marker object for movedMarkers
    // add all marker options   
    
    const markerObject = {
        options: {...marker.options},
        latitude: marker.getLatLng().lat,
        longitude: marker.getLatLng().lng,
        old_position: {
            latitude: marker.options.latitude,
            longitude: marker.options.longitude
        },// Add or override any other properties here
    };

    // If the marker is not in the array, add it
    if (index === -1) {
        movedMarkers.push(markerObject);
    } else {
        // If the marker is already in the array, update its properties
        movedMarkers[index] = markerObject;
    }

}
function fixAntimeridianMarkers() {
    // get all layers (not just markers)
    const layers = map._layers;

    // loop through all layers
    Object.values(layers).forEach(layer => {
        // ignore non-marker instances
        if (layer instanceof L.Marker) {
            let lng = layer.getLatLng().lng;
            
            // Adjust for markers over the antimeridian
            if (lng > 180) {
                layer.setLatLng([layer.getLatLng().lat, lng - 360]);
            } else if (lng < -180) {
                layer.setLatLng([layer.getLatLng().lat, lng + 360]);
            }
        }
    });
}


function toggleMarkerSelection(e) {
    let marker = e.target;
    if (marker.options.hidden) {
        return;
    }
    //console.log("Marker Clicked: ", marker);
    marker.dragging.enable();
    if (e.originalEvent.ctrlKey) {
        // Ctrl key pressed: Toggle selection for the clicked marker
        const index = selectedMarkers.indexOf(marker);
        if (index > -1) {
            // Marker is already selected, so deselect it
            selectedMarkers.splice(index, 1);
            updateMarkerStyle(false, marker);
        } else {
            // Marker is not selected, so select it
            selectedMarkers.push(marker);
            updateMarkerStyle(true, marker);
        }
    } else {
        // Ctrl key not pressed: Check if the clicked marker is the only one selected
        if (selectedMarkers.includes(marker)) {
            // Marker is already selected and no Ctrl key, so deselect it
            const index = selectedMarkers.indexOf(marker);
            selectedMarkers.splice(index, 1); // Remove from selectedMarkers
            updateMarkerStyle(false, marker);
        } else {
            // If it's not in the selection, deselect all others and select this one
            selectedMarkers.forEach(m => updateMarkerStyle(false, m)); // Deselect all
            selectedMarkers = [marker]; // Reset and select this one
            updateMarkerStyle(true, marker);
        }
    }
    if (!marker.options.textMarker) {
        // the follow code filters the datatable for the selected markers by their unique_ids
        const uniqueIdColumnIndex = 0; // this is the unique_id column index
        selectedMarkersByUniqueID = selectedMarkers.map(marker => marker.options.unique_id);
        //console.log("Selected Markers: ", selectedMarkersByUniqueID);
        filterDataTableByUniqueIds(selectedMarkersByUniqueID, uniqueIdColumnIndex);
    }
    if (selectedMarkers.length == 0) {
        clearFilters();
    }

}


function toggleShapeSelection(e) {
    console.log("Polygon Clicked");
    let polygon = e.target;
    if (polygon.options.hidden) {
        return;
    }
    //console.log("Polygon Clicked: ", polygon);
    if (e.originalEvent.ctrlKey) {
        // Ctrl key pressed: Toggle selection for the clicked polygon
        const index = selectedShapes.indexOf(polygon);
        if (index > -1) {
            // Polygon is already selected, so deselect it
            selectedShapes.splice(index, 1);
            updateShapeStyle(false, polygon);
        } else {
            // Polygon is not selected, so select it
            selectedShapes.push(polygon);
            updateShapeStyle(true, polygon);
        }
    } else {
        // Ctrl key not pressed: Check if the clicked polygon is the only one selected
        if (selectedShapes.includes(polygon)) {
            // Polygon is already selected and no Ctrl key, so deselect it
            const index = selectedShapes.indexOf(polygon);
            selectedShapes.splice(index, 1); // Remove from selectedShapes
            updateShapeStyle(false, polygon);
        } else {
            // If it's not in the selection, deselect all others and select this one
            selectedShapes.forEach(p => updateShapeStyle(false, p)); // Deselect all
            selectedShapes = [polygon]; // Reset and select this one
            updateShapeStyle(true, polygon);
        }
    }

}


$(document).ready(function() {
    // Listener for the "Load" button click
    $('#loadSavedFile').on('click', function() {
        // Get the value from the input box
        var uuid = $('#uuidInput').val();
        
        // Run your custom function
        loadFromUUID(uuid);

        // Close the modal
        $('#uuidModal').modal('hide');
    });
});

var currentGlobalUuid = null;
function loadFromUUID(uuid) {
    // Logic to load file from UUID
    console.log("Loading file from UUID:", uuid);
    var url = "{% url 'load_great_file' '6a3274e6-7f7b-4a46-9246-3d1fa546f3ee' %}".replace('/6a3274e6-7f7b-4a46-9246-3d1fa546f3ee', '') + uuid + "/";
    // send ajax Get
    $.ajax({
        type: "GET",
        url: url,
        dataType: "json",
        processData: true,  // Prevent jQuery from automatically transforming the data into a query string
        success: function(data) {
            //console.log(data.status);
            if (data.status == "success") {
                hideSpinnerModal();
                //console.log(data.data);
                const loadedData = data.data;
                loadSavedMapData(loadedData);
                currentGlobalUuid = uuid;
                
            }
        },
        error: function(xhr, status, error) {
            
            if (xhr.status == 404 || xhr.status == 400) {
                hideSpinnerModal();
                showFailureModal("Invalid UUID");
            } else {
                console.error("Error loading file from UUID:", error);
                var errorMessage = xhr.status + ': ' + xhr.statusText;
                console.log('Error - ' + errorMessage);
                showFailureModal(errorMessage);
            }
            
        }
    });



}




// Function to convert marker data to CSV
function convertMarkersToCSV(markersArray) {
    var csvContent = "latitude,longitude,unique_id\n"; // CSV header
    markersArray.forEach(function(marker) {
        csvContent += marker.lat + ',' + marker.lng + ',' + marker.unique_id + '\n';
    });
    return csvContent;
}

// Function to restore markers to their original locations
function restoreMarkerMoves() {
    //changeRangeRingsSelection('[Off] AD Rings');
    //changeUnitRingsSelection('[Off] Unit Rings');
    console.log("Restoring Markers");

    originalMarkers.forEach(function(originalMarker) {
        // Loop through all layers on the map
        map.eachLayer(function(layer) {
            if (layer instanceof L.LayerGroup && layer.getLayers !== undefined) {
                // Loop through all markers within the layer
                layer.getLayers().forEach(function(currentMarker) {
                    // Check if currentMarker matches an originalMarker AND is in the movedMarkers array
                    if (currentMarker instanceof L.Marker && 
                        currentMarker.options.unique_id === originalMarker.options.unique_id &&
                        movedMarkers.some(movedMarker => movedMarker.options.unique_id === currentMarker.options.unique_id)) {
                        
                        //console.log("Moving From: " + currentMarker.options.latitude + ", " + currentMarker.options.longitude);
                        //console.log("Restoring To: " + originalMarker.options.latitude + ", " + originalMarker.options.longitude);
                        // Restore the marker's original position
                        var originalPosition = L.latLng(originalMarker.options.latitude, originalMarker.options.longitude);
                        currentMarker.setLatLng(originalPosition);
                        currentMarker.options.latitude = originalMarker.options.latitude; 
                        currentMarker.options.longitude = originalMarker.options.longitude;
                        currentMarker.dragging.enable();
                        // if the marker has range rings, update them
                        updateRangeRings(currentMarker);
                    }
                });
            }         
        });    
    });

    // Clear the movedMarkers array after restoring the markers
    movedMarkers = [];
    //removeAllGeometries();
    //restoreMapGeometries(map, savedGeometriesArray);
}

// hotkeys

document.addEventListener('keydown', function(event) {
    // stop Ctrl + S from saving the page
    if ((event.key === "s" || event.keyCode === 83) && (event.ctrlKey || event.metaKey)) { // "s" for modern browsers, keyCode 83 for older ones
        event.preventDefault();
    }
    // Ctrl + Z to undo movements
    if ((event.key === "z" || event.keyCode === 90) && (event.ctrlKey || event.metaKey)) { // "z" for modern browsers, keyCode 90 for older ones
        event.preventDefault();
        undoMovements();
    }
    // Ctrl + Y to redo movements
    if ((event.key === "y" || event.keyCode === 89) && (event.ctrlKey || event.metaKey)) { // "y" for modern browsers, keyCode 89 for older ones
        event.preventDefault();
        redoMovements();
    }
    // Ctlr + I to invert selection
    if ((event.key === "i" || event.keyCode === 73) && (event.ctrlKey || event.metaKey)) { // "i" for modern browsers, keyCode 73 for older ones
        event.preventDefault();
        invertSelection();
    }
    if ((event.key === "Delete" || event.keyCode === 46) && (event.ctrlKey || event.metaKey)) { // "Delete" for modern browsers, keyCode 46 for older ones
        //console.log("Delete Key Pressed");
        selectedTextMarkers.forEach(function(textMarker) {
            map.removeLayer(textMarker);
        });
        selectedTextMarkers = [];
        selectedShapes.forEach(function(polygon) {
            map.removeLayer(polygon);
        });
        selectedShapes = [];
    }
    if ((event.key === "a" || event.keyCode === 65) && (event.ctrlKey || event.metaKey)) { // "a" for modern browsers, keyCode 65 for older ones
        // stop default behavior
        event.preventDefault();
        selectAllVisibleMarkers(); // Select all visible markers
    }
    if ((event.key === "Escape" || event.keyCode === 27)) { // "Escape" for modern browsers, keyCode 27 for older ones
        event.preventDefault();
        // cancel any pm actions
        cancelGeomanActions();
        //enableGeomanActions();
    }
    // d key deselects all markers
    if ((event.key === "d" || event.keyCode === 68) && (event.ctrlKey || event.metaKey)) { // "d" for modern browsers, keyCode 68 for older ones
        event.preventDefault();
        deselectMarkers(); // Deselect all markers
    }
});

function cancelGeomanActions() {
    map.pm.disableGlobalEditMode();        // Cancel any active edit actions
}

function enableGeomanActions() {
    map.pm.enableGlobalEditMode();        // Enable edit actions
}


// function to remove all geometries
function removeAllGeometries() {
    map.eachLayer(function(layer) {
        if (layer instanceof L.Polygon || layer instanceof L.Polyline || layer instanceof L.Circle || layer instanceof L.Rectangle) {
            map.removeLayer(layer);
        }
    });
}

var globalLayerAssignments = {};
// structure of globalLayerAssignments
// {
//     "layerName": {
//         "name": "layerName",
//         "visible": true,
//         "markers": [marker1, marker2, marker3],
//         "polygons": [polygon1, polygon2, polygon3],
//         "textMarkers": [textMarker1, textMarker2, textMarker3]
//     }

function addToLayer(layerName, item = null) {
    // Helper function to determine the type of the item and assign it to the correct array
    function assignToLayer(item) {
        //console.log("Assigning Item to Layer:", layerName);
        //console.log("Item:", item);

        // Ensure item.options.assignedLayers exists
        if (!item.options.assignedLayers) {
            item.options.assignedLayers = [layerName];
        } else if (!item.options.assignedLayers.includes(layerName)) {
            item.options.assignedLayers.push(layerName);
        }

        // Determine the type of the item (Marker, Polygon, or TextMarker)
        const isMarker = item instanceof L.Marker;
        const isTextMarker = isMarker && item.options.textMarker === true;
        const isPolygon = item instanceof L.Polygon || item instanceof L.Polyline || item instanceof L.Circle || item instanceof L.CircleMarker;

        let itemType = "Unknown";
        let targetArray;

        // Initialize layer if necessary
        createNewLayer(layerName);

        if (isTextMarker) {
            itemType = "TextMarker";
            targetArray = globalLayerAssignments[layerName].textMarkers;
        } else if (isMarker) {
            itemType = "Marker";
            targetArray = globalLayerAssignments[layerName].markers;
        {% comment %} } else if (isPolygon) {
            itemType = "Polygon";
            targetArray = globalLayerAssignments[layerName].polygons;
        }
        if (itemType === "Unknown") {
            console.error("Unknown item type:", item);
            return;
        } {% endcomment %}

        } else {
            itemType = "Polygon";
            targetArray = globalLayerAssignments[layerName].polygons;
        }
        
        //console.log(`Adding ${itemType} to Layer:`, layerName);

        // Add the item to the appropriate array and ensure uniqueness
        if (!targetArray.includes(item)) {
            targetArray.push(item);
        }
    }

    // If a specific item is provided, assign it; otherwise, assign all selected items
    if (item) {
        assignToLayer(item);
    } else {
        selectedMarkers.forEach(assignToLayer);
        selectedShapes.forEach(assignToLayer);
        selectedTextMarkers.forEach(assignToLayer);  // Add this line to handle textMarkers
    }
}



function createNewLayer(layerName) {
    
    if (!globalLayerAssignments[layerName]) {
        //console.log("Creating New Layer: ", layerName);
        globalLayerAssignments[layerName] = {name: layerName, visible: true, markers: [], polygons: [], textMarkers: []};
    } else {
        //console.log("Layer already exists: ", layerName);
    }
}

function removeItemFromLayer(layerName, item) {
    // Helper function to remove an item (marker, textMarker, or polygon) from the specified layer
    function unassignFromLayer(item) {
        const isMarker = item instanceof L.Marker;
        const isTextMarker = isMarker && item.options.textMarker === true;
        const isPolygon = !isMarker && !isTextMarker;

        // Remove the layerName from the assignedLayers array
        if (Array.isArray(item.options.assignedLayers)) {
            item.options.assignedLayers = item.options.assignedLayers.filter(layer => layer !== layerName);
        }

        // Remove the item from the globalLayerAssignments
        if (globalLayerAssignments[layerName]) {
            console.log("Removing Item from Layer:", layerName);
            let targetArray;

            if (isTextMarker) {
                targetArray = globalLayerAssignments[layerName].textMarkers;
                globalLayerAssignments[layerName].textMarkers = targetArray.filter(m => m !== item);
            } else if (isMarker) {
                targetArray = globalLayerAssignments[layerName].markers;
                globalLayerAssignments[layerName].markers = targetArray.filter(m => m !== item);
            } else if (isPolygon) {
                targetArray = globalLayerAssignments[layerName].polygons;
                globalLayerAssignments[layerName].polygons = targetArray.filter(m => m !== item);
            }
        }
    }

    unassignFromLayer(item);
}

function removeFromLayer(layerName) {
    console.log("Removing items from Layer:", layerName);

    // Helper function to remove an item (marker, textMarker, or polygon) from the specified layer
    function unassignFromLayer(item) {
        const isMarker = item instanceof L.Marker;
        const isTextMarker = isMarker && item.options.textMarker === true;
        const isPolygon = item instanceof L.Polygon || item instanceof L.CircleMarker || item instanceof L.Circle || item instanceof L.Polyline;

        // Remove the layerName from the assignedLayers array
        if (Array.isArray(item.options.assignedLayers)) {
            item.options.assignedLayers = item.options.assignedLayers.filter(layer => layer !== layerName);
        }

        // Remove the item from the globalLayerAssignments
        if (globalLayerAssignments[layerName]) {
            let targetArray;

            if (isTextMarker) {
                targetArray = globalLayerAssignments[layerName].textMarkers;
                globalLayerAssignments[layerName].textMarkers = targetArray.filter(m => m !== item);
            } else if (isMarker) {
                targetArray = globalLayerAssignments[layerName].markers;
                globalLayerAssignments[layerName].markers = targetArray.filter(m => m !== item);
            } else if (isPolygon) {
                targetArray = globalLayerAssignments[layerName].polygons;
                globalLayerAssignments[layerName].polygons = targetArray.filter(m => m !== item);
            }
        }
    }

    // Apply to all selected markers, textMarkers, and polygons
    selectedMarkers.forEach(unassignFromLayer);
    selectedShapes.forEach(unassignFromLayer);
    selectedTextMarkers.forEach(unassignFromLayer);  // Add this line to handle textMarkers
}



function selectAllVisibleMarkers() {
    deselectMarkers();
    map.eachLayer(function(layer) {
        if ((layer instanceof L.Marker || layer.pm?._shape) && !layer.options.hidden) {
            // handle markers
            if (layer instanceof L.Marker && !layer.options.textMarker) {
                selectedMarkers.push(layer);
                updateMarkerStyle(true, layer);
            }

            // handle polygons
            else if (layer.pm?._shape && ! layer.options.textMarker) {
                selectedShapes.push(layer);
                updateShapeStyle(true, layer);
            }

            // handle textMarkers
            else if (layer instanceof L.Marker && layer.options.textMarker) {
                selectedTextMarkers.push(layer);
                updateMarkerStyle(true, layer);
            }

        }
    });
}

function selectMarkersByLayer(layerName) {
    //console.log("Selecting Markers in Layer:", layerName);
    if (globalLayerAssignments[layerName]) {
        globalLayerAssignments[layerName].markers.forEach(function(marker) {
            selectedMarkers.push(marker);
            updateMarkerStyle(true, marker);
        });
        globalLayerAssignments[layerName].polygons.forEach(function(polygon) {
            selectedShapes.push(polygon);
            updateShapeStyle(true, polygon);
        });
        globalLayerAssignments[layerName].textMarkers.forEach(function(textMarker) {
            selectedTextMarkers.push(textMarker);
            updateMarkerStyle(true, textMarker);
        });
    }
}

function restoreMapGeometries(map, geometries) {
    geometries.forEach(geometry => {
        let layer;
        switch (geometry.type) {
            case 'Circle':
                layer = L.circle(geometry.properties.center, geometry.properties.options);
                break;
            case 'Polygon':
                layer = L.polygon(geometry.properties.latLngs, geometry.properties.options);
                break;
            case 'Polyline':
                layer = L.polyline(geometry.properties.latLngs, geometry.properties.options);
                break;
            case 'Rectangle':
                layer = L.rectangle(geometry.properties.latLngs, geometry.properties.options);
                break;
            // Handle other types as needed
        }

        if (layer) {
            // Add the layer to the map or a specific feature group
            layer.addTo(map); // Or to a specific layer group if you're using one

            // Attach click event to change the layer's color
            layer.on('dblclick', function(e) {
                L.DomEvent.stopPropagation(e);
                var colorPicker = document.getElementById('color-picker');
                if (colorPicker) {
                    layer.setStyle({ color: colorPicker.value });
                }
            });
        }
    });
}

function saveMapGeometries(map) {
    let geometries = [];

    map.eachLayer(layer => {
        let geometry = { type: '', properties: {} };

        if (layer instanceof L.Circle) {
            geometry.type = 'Circle';
            geometry.properties = {
                center: layer.getLatLng(),
                radius: layer.getRadius(),
                options: layer.options
            };
        } else if (layer instanceof L.Polygon) {
            geometry.type = 'Polygon';
            geometry.properties = {
                latLngs: layer.getLatLngs(),
                options: layer.options
            };
        } else if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
            geometry.type = 'Polyline';
            geometry.properties = {
                latLngs: layer.getLatLngs(),
                options: layer.options
            };
        } else if (layer instanceof L.Rectangle) {
            geometry.type = 'Rectangle';
            geometry.properties = {
                latLngs: layer.getLatLngs(),
                options: layer.options
            };
        } 
        // Handling for Text Layers
        else if (layer instanceof L.Marker && layer.options.textMarker) {
            geometry.type = 'TextMarker';
            geometry.properties = {
                latLng: layer.getLatLng(),
                text: layer.options.text, // Directly save the text content
                // Include any other relevant options you might need
            };
            // TODO - remove popups on text markers
        }

        // Only add the geometry if a type was set
        if (geometry.type) {
            geometries.push(geometry);
        }
    });

    return geometries;
}


// Function to export marker data to CSV
function exportMarkersToCSV() {
    var markersArray = []; // Array to hold marker data
    map.eachLayer(function(layer) {
        if (layer instanceof L.Marker) { // Check if layer is a marker
            var markerData = {
                lat: layer.getLatLng().lat,
                lng: layer.getLatLng().lng,
                unique_id: layer.options.unique_id
            };
            markersArray.push(markerData);
        }
    });

    var csvContent = convertMarkersToCSV(markersArray);
    var blob = new Blob([csvContent], { type: 'text/csv' });
    var link = document.createElement('a');
    link.setAttribute('href', window.URL.createObjectURL(blob));
    link.setAttribute('download', 'markers.csv');
    link.click();
}


// remove id attribute of elem with front-theater-assignment class // prevents endless loop
$("select.front-theater-assignment").removeAttr("id");

// get change to #id_assignment
$(document).on("change","select.front-theater-assignment",function(){
    //$("option[value=" + this.value + "]", this).attr("selected", true).siblings().removeAttr("selected");
    var assignment = this.value;
    $("select.front-theater-assignment").val(assignment);
    //console.log("Selected Assignment:", assignment);
    
    $("div > select#id_assignment").val(assignment).trigger('change');
    // disable drag for all markers not in this assignment
    map.eachLayer(function(layer) {
        if (layer instanceof L.Marker) {
            if (layer.options.assignment != assignment) {
                layer.dragging.disable();
            } else {
                layer.dragging.enable();
            }
        }
    });  
    
});

function updateSvgIconSize(newSize) {
    map.eachLayer(function(layer) {
        if (layer instanceof L.Marker && layer.options.icon.options.className === 'custom-div-icon') {
            var newIcon = L.divIcon({
                className: 'custom-div-icon',
                html: layer.options.icon.options.html, // Assuming this is your SVG HTML
                iconSize: [newSize, newSize], // New dynamic size based on zoom level
                iconAnchor: [newSize / 2, newSize / 2] // Adjust anchor accordingly
            });
            layer.setIcon(newIcon);
        }
    });
}


document.getElementById('search-input').addEventListener('input', function(e) {
    var searchValue = e.target.value.toLowerCase();
    matchedMarkers.length = 0; // Reset matched markers array
    searchableMarkers.forEach(function(marker, i) {
        if (marker.options.details.toLowerCase().includes(searchValue)) {
            matchedMarkers.push(marker); // Add matching markers to array
        }
    });
    currentMarkerIndex = 0; // Reset index with new search
    if (matchedMarkers.length > 0) {
        map.panTo(matchedMarkers[0].getLatLng());
        matchedMarkers[0].bindPopup(matchedMarkers[0].options.details)
        matchedMarkers[0].openPopup();
    }
});

document.addEventListener('keydown', function(e) {
    if (e.key === 'Enter' && matchedMarkers.length > 0) {
        currentMarkerIndex = (currentMarkerIndex + 1) % matchedMarkers.length; // Cycle through matched markers
        map.panTo(matchedMarkers[currentMarkerIndex].getLatLng());
        matchedMarkers[currentMarkerIndex].openPopup();
        e.preventDefault(); // Prevent default Enter key action
    }
});

// JavaScript for toggle button functionality
document.getElementById('dblClickBtn').addEventListener('click', function() {
    // Assuming the function for Dbl Click behavior is dblClickFunction()
    //dblClickFunction();
    enableDblClick();
    disableHover();
    this.classList.add('active');
    this.classList.add('btn-success');
    document.getElementById('hoverBtn').classList.remove('active');
    document.getElementById('hoverBtn').classList.remove('btn-success');
    document.getElementById('hoverBtn').classList.add('btn-secondary');
});

document.getElementById('hoverBtn').addEventListener('click', function() {
    // Assuming the function for Hover behavior is hoverFunction()
    enableHover();
    disableDblClick();
    this.classList.add('active');
    this.classList.add('btn-success');
    document.getElementById('dblClickBtn').classList.remove('active');
    document.getElementById('dblClickBtn').classList.remove('btn-success');
    document.getElementById('dblClickBtn').classList.add('btn-secondary');
});

// listen for mouse wheel option
var mouseWheelState = true;
document.getElementById('mouseWheelDisable').addEventListener('click', function() {
    // Assuming the function for Mouse Wheel behavior is mouseWheelFunction()
    this.classList.add('active');
    this.classList.add('btn-success');
    this.classList.remove('btn-secondary');
    document.getElementById('mouseWheelEnable').classList.remove('active');
    document.getElementById('mouseWheelEnable').classList.remove('btn-success');
    document.getElementById('mouseWheelEnable').classList.add('btn-secondary');
    mouseWheelState = false;
    map.scrollWheelZoom.disable();
});

document.getElementById('mouseWheelEnable').addEventListener('click', function() {
    // Assuming the function for Mouse Wheel behavior is mouseWheelFunction()
    this.classList.add('active');
    this.classList.add('btn-success');
    this.classList.remove('btn-secondary');
    document.getElementById('mouseWheelDisable').classList.remove('active');
    document.getElementById('mouseWheelDisable').classList.remove('btn-success');
    document.getElementById('mouseWheelDisable').classList.add('btn-secondary');
    mouseWheelState = true;
    map.scrollWheelZoom.enable();
});

document.getElementById('mapDragDisable').addEventListener('click', function() {
    // Assuming the function for Mouse Wheel behavior is mouseWheelFunction()
    this.classList.add('active');
    this.classList.add('btn-success');
    this.classList.remove('btn-secondary');
    document.getElementById('mapDragEnable').classList.remove('active');
    document.getElementById('mapDragEnable').classList.remove('btn-success');
    document.getElementById('mapDragEnable').classList.add('btn-secondary');
    map.dragging.disable();
});

document.getElementById('mapDragEnable').addEventListener('click', function() {
    // Assuming the function for Mouse Wheel behavior is mouseWheelFunction()
    this.classList.add('active');
    this.classList.add('btn-success');
    this.classList.remove('btn-secondary');
    document.getElementById('mapDragDisable').classList.remove('active');
    document.getElementById('mapDragDisable').classList.remove('btn-success');
    document.getElementById('mapDragDisable').classList.add('btn-secondary');
    map.dragging.enable();
});


// Implement dblClickFunction() and hoverFunction() as needed

function enableHover () {
    //console.log("Enabling Hover for popups");
    map.eachLayer(function(layer) {
        if (layer instanceof L.Marker) {
            layer.on('mouseover', function(e) {
                // Implement the desired behavior for mouseover
                //console.log("Mouse Over Marker: ", e.target);
                updatePopupDetails(e.target);
                e.target.bindPopup(e.target.options.customPopupContent);
                e.target.openPopup();
            });
            layer.on('mouseout', function(e) {
                // Implement the desired behavior for mouseout
                e.target.closePopup();
            });
        }
    });
}

function disableHover() {
    //console.log("Disabling Hover for popups");
    map.eachLayer(function(layer) {
        if (layer instanceof L.Marker) {
            layer.off('mouseover');
            layer.off('mouseout');
        }
    });
}

function disableDblClick() {
    //console.log("Disabling Dbl Click for popups");
    map.eachLayer(function(layer) {
        if (layer instanceof L.Marker) {
            layer.off('dblclick');
        }
    });

}

function enableDblClick() {
    //console.log("Enabling Dbl Click for popups");
    map.eachLayer(function(layer) {
        if (layer instanceof L.Marker) {
            layer.on('dblclick', function(e) {
                // Implement the desired behavior for dblclick
                e.target.bindPopup(e.target.options.details);
                e.target.openPopup();
            });
        }
    });
}

// Populate the filter modal

function populateFilterModal() {
    // Get unique domains
    let uniqueDomains = new Set();

    // Get unique countries
    let uniqueCountries = new Set();

    // Get unique unit_types
    let uniqueUnitTypes = new Set();

    // get all markers on map
    map.eachLayer(function(layer) {
        if (layer instanceof L.Marker) {
            uniqueDomains.add(layer.options.domain);
            uniqueCountries.add(layer.options.country);
            uniqueUnitTypes.add(layer.options.unit_type);
        }
    });

    // Remove all current options from the filter modal
    document.getElementById('chooser-domain').innerHTML = '';
    document.getElementById('chooser-country').innerHTML = '';
    document.getElementById('chooser-unitType').innerHTML = '';


    // Populate the filter modal with unique values
    let domainFilter = document.getElementById('chooser-domain');
    uniqueDomains.forEach(function(domain) {
        let option = document.createElement('option');
        option.value = domain;
        option.text = domain;
        domainFilter.add(option);
    });

    let countryFilter = document.getElementById('chooser-country');
    uniqueCountries.forEach(function(country) {
        let option = document.createElement('option');
        option.value = country;
        option.text = country;
        countryFilter.add(option);
    });

    let unitTypeFilter = document.getElementById('chooser-unitType');
    uniqueUnitTypes.forEach(function(unitType) {
        let option = document.createElement('option');
        option.value = unitType;
        option.text = unitType;
        unitTypeFilter.add(option);
    });
}


// button click listener for hideByCountryBtn
$(document).ready(function() {
    // Event handler for the "Show Selected" button
    $('#showByCountryBtn').click(function() {
        var selectedOptions = $('#chooser-country').val();
        if (selectedOptions) {
            //console.log("Selected Options: ", selectedOptions);
            // loop through selectedOptions
            selectedOptions.forEach(function(selectedOption) {
                showMarkersByCountry(selectedOption);
            });
        }
    });

    $('#showByDomainBtn').click(function() {
        var selectedOptions = $('#chooser-domain').val();
        if (selectedOptions) {
            //console.log("Selected Options: ", selectedOptions);
            // loop through selectedOptions
            selectedOptions.forEach(function(selectedOption) {
                showMarkersByDomain(selectedOption);
            });
        }
    });

    $('#showByUnitTypeBtn').click(function() {
        var selectedOptions = $('#chooser-unitType').val();
        if (selectedOptions) {
            //console.log("Selected Options: ", selectedOptions);
            // loop through selectedOptions
            selectedOptions.forEach(function(selectedOption) {
                showMarkersByUnitType(selectedOption);
            });
        }
    });

    $('#hideByCountryBtn').click(function() {
        var selectedOptions = $('#chooser-country').val();
        if (selectedOptions) {
            //console.log("Selected Options: ", selectedOptions);
            // loop through selectedOptions
            selectedOptions.forEach(function(selectedOption) {
                hideMarkersByCountry(selectedOption);
            });
        }
    });

    $('#hideByDomainBtn').click(function() {
        var selectedOptions = $('#chooser-domain').val();
        if (selectedOptions) {
            //console.log("Selected Options: ", selectedOptions);
            // loop through selectedOptions
            selectedOptions.forEach(function(selectedOption) {
                hideMarkersByDomain(selectedOption);
            });
        }
    });

    $('#hideByUnitTypeBtn').click(function() {
        var selectedOptions = $('#chooser-unitType').val();
        if (selectedOptions) {
            //console.log("Selected Options: ", selectedOptions);
            // loop through selectedOptions
            selectedOptions.forEach(function(selectedOption) {
                hideMarkersByUnitType(selectedOption);
            });
        }
    });

});



// Datatable functions

function filterDataTableByUniqueIds(searchTerms, columnIndex) {
    //console.log('Filtering DataTable by Unique IDs:', searchTerms);
  
    // if searchTerms is a string, convert it to an array
    if (typeof searchTerms === 'string') {
        searchTerms = [searchTerms];
    }
  
    // Escape special characters in each search term to safely use them in a regex
    function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
    }
  
    // Escape each term and join them into a regex pattern separated by '|'
    let regex = searchTerms.map(escapeRegExp).join('|');
  
    let table = $('#MapDataTable').DataTable();
  
    // If the searchTerms array is empty, clear the search to show all rows
    if (searchTerms.length === 0) {
        table.column(columnIndex).search('');
    } else {
        // Apply the regex search to the specified column, enabling regex and smart search
        table.column(columnIndex).search(regex, true, true);
    }
  
    // Redraw the table to apply the filter
    table.draw();
}

function searchMarkerinMap(unique_id) {
    let maxZIndex = 0;

    // First, find the maximum zIndex of all markers
    searchableMarkers.forEach(function(marker) {
        let currentZIndex = marker.options.zIndexOffset || 0;
        if (currentZIndex > maxZIndex) {
            maxZIndex = currentZIndex;
        }
    });

    searchableMarkers.forEach(function(marker) {
        if (marker.options.unique_id.includes(unique_id)) {
            // Bring this marker to the top by setting its zIndex higher than the current maximum
            marker.setZIndexOffset(maxZIndex + 1);

            // Pan to the marker
            map.panTo(marker.getLatLng(), {animate: false});
            
            // Optionally zoom in
            // map.setZoom(5);

            // Bind and open the popup
            marker.bindPopup(marker.options.details);
            marker.openPopup();

            // Add class found-marker-green
            // marker._icon.classList.add('found-marker-green');
        }
    });
}

var dataTable;
function initDatatable(){
    console.log("Initializing DataTable");

    // retrieve a single marker's options.dataTable
    var unitMarkersJsonObjects = [];
    map.eachLayer(function(layer) {
        if (layer instanceof L.Marker && layer.options.dataTable) {
            // append to unitMarkersJsonObjects
            unitMarkersJsonObjects.push(layer.options.dataTable);
        }
        
    });

    // if length of unitMarkersJsonObjects is 0, return
    if (unitMarkersJsonObjects.length === 0) {
        console.warn("No markers with DataTable options found");
        return;
    }

    // keys based on filteredJsonObjects
    var keys = Object.keys(unitMarkersJsonObjects[0]);
    //console.log("Keys: ", keys);

    // check if table exists, if so destroy it
    if ($.fn.DataTable.isDataTable('#MapDataTable')) {
        try {
            $('#MapDataTable').DataTable().destroy(); // Clear existing table data to avoid duplication
        } catch (error) {
            console.error("Error destroying DataTable:", error);
            // remove the table
            $('#MapDataTable').remove();

        }
    }
    

    // normalize the values, if a key value is null or undefined, set it to empty string
    unitMarkersJsonObjects = unitMarkersJsonObjects.map(function(obj){
        return keys.reduce((acc, key) => {
            acc[key] = obj[key] || '';
            return acc;
        }, {});
    });


    // create the jquery datatable
    dataTable = $('#MapDataTable').DataTable({
        deferRender: true,
        data: unitMarkersJsonObjects,
        columns: keys.map(function(key, index) {
            if (index === 0) {
                // Custom definition for column 0
                return {
                    data: 'unique_id',
                    title: "ID",
                    tooltip: "The unit's unique identifier for reference",
                    className: 'always-visible',
                    visible: true,
                    colIndex: 1,
                    render: function(data, type, row, meta) {
                        const title = Object.entries(row).map(([key, value]) => `${key}: ${value}`).join('<br>');
                        const zoomToMarker = `<button class="dt-icon" type="link"><i class="bi bi-binoculars-fill modal-btn m-0 p-0 pe-1" data-bs-toggle="tooltip" title="Pan to unit" onclick="searchMarkerinMap('${row.unique_id}')"></i></button>`;
                        return zoomToMarker + row.unique_id;
                    }
                };
            } else {
                // Default definition for other columns
                return {
                    data: key,
                    title: key.charAt(0).toUpperCase() + key.slice(1) // Capitalize the first letter of each column name
                };
            }
        }),
        paging: true,
        searching: true,
        ordering: true,
        autoWidth: false,
        responsive: true,
        scrollX: true,
        scrollY: '70vh',
        scrollCollapse: true,
        //colReorder: true,
        dom: '<"top"lBf>rtip', // This option defines the table control elements to appear on the page (Buttons, Filter, etc.)
        buttons: [
            {
            extend: 'colvis', // Adds the column visibility button
            columns: ':not(.always-visible)', // Excludes the first column from the column visibility button
            className: 'btn-sm btn-primary mx-2',
            text: 'Add Columns'
            },        
        ],
        columnDefs: [
            {
                targets: '_all',
                className: 'dt-left'
            }
        ], 
    });
    $(window).resize(function() {
        dataTable.columns.adjust().draw();
    });
    // Trigger the custom event using jQuery
    var event = new CustomEvent('initDatatableComplete');
    document.dispatchEvent(event);
    console.log("DataTable Initialized - Event Sent");
}

function clearFilters() {
    try {
        $('#MapDataTable').DataTable().search('').columns().search('').draw();
    } catch (error) {
        if (error.message.includes('undefined')) {
        } else {
            console.error("Error clearing filters:", error);
        }
    }
}

function prepDataExport(data) {
    // only include these keys in the export
    keysToKeep = ["domain", "country", "latitude", "unit_type", "longitude", "unit_assignment", "unique_id", "class_3_burn_rate", "class_5_burn_rate", "current_class_3_supply", "current_class_5_supply", "equipment", "generation", "health", "max_class_3_capacity", "max_class_5_capacity"];
    // remove all other keys
    data = data.map(function(obj){
        return Object.keys(obj)
            .filter(key => keysToKeep.includes(key))
            .reduce((acc, key) => {
                acc[key] = obj[key];
                return acc;
            }, {});
    });
    return data;
}

$("#exportBtn").on("click", function() {
    let table = $('#MapDataTable').DataTable();
    let data = table.rows().data().toArray(); // Ensure data is in array format
    //data = prepDataExport(data);
    
    
    
    let text = '';
  
    if (data.length > 0 && typeof data[0] === 'object') {
      let headers = Object.keys(data[0]).join(',');
      text += headers + '\n'; // Add headers to CSV text
    }
  
    data.forEach(row => {
      // Assuming all rows are objects with the same keys in the same order
      let rowValues = Object.values(row).join(',');
      text += rowValues + '\n';
    });
  
    // Create a Blob with the CSV content
    let blob = new Blob([text], {type: "text/csv;charset=utf-8"});
    saveAs(blob, 'tableExport-All.csv');
  });
  
$("#exportBtn-view").on("click", function() {
    // export only the rows in the current datatable view
    let table = $('#MapDataTable').DataTable();
    let data = table.rows({search: 'applied'}).data().toArray(); // Ensure data is in array format
    //data = prepDataExport(data);
    let text = '';

    if (data.length > 0 && typeof data[0] === 'object') {
        let headers = Object.keys(data[0]).join(',');
        text += headers + '\n'; // Add headers to CSV text
    }

    data.forEach(row => {
        // Assuming all rows are objects with the same keys in the same order
        let rowValues = Object.values(row).join(',');
        text += rowValues + '\n';
    });

    // Create a Blob with the CSV content
    let blob = new Blob([text], {type: "text/csv;charset=utf-8"});
    saveAs(blob, 'tableExport-View.csv');
});
// Datatables needs to adjust the columns when the element is expanded
$('#collapseDatatable').on('shown.bs.collapse', function () {
    try {
        dataTable.columns.adjust().draw(); // Adjust columns when the element is expanded
    } catch (error) {
        
    }
});

initMap();

// on page load show the new features modal
$(document).ready(function() {
    $('#newFeaturesModal').modal('show');
});


</script>

{% endblock %}
